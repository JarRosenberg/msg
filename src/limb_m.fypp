! Module  : limb_m
! Purpose : define limb_t type, representing limb-darkening laws
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module limb_m

   ! Uses

   use kinds_m
   use hdf5io_m

   use const_m
   use fit_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Parameter definitions

   integer, parameter :: LINEAR_LAW = 1
   integer, parameter :: QUAD_LAW = 2
   integer, parameter :: CLARET_LAW = 3

   ! Derived-type definitions

   type limb_t
      private
      integer, public :: law = 0
   contains
      private
      procedure, public :: n_basis
      procedure, public :: intensity_basis
      procedure, public :: flux_basis
      procedure, public :: D_moment_basis
      procedure         :: fit_intensity_0_
      procedure         :: fit_intensity_1_
      generic, public   :: fit_intensity => fit_intensity_0_, fit_intensity_1_
   end type limb_t

   ! Interfaces

   interface limb_t
      module procedure limb_t_
   end interface limb_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: LINEAR_LAW
   public :: QUAD_LAW
   public :: CLARET_LAW
   public :: limb_t
   public :: read
   public :: write

   ! Procedures

contains

   function limb_t_(law) result (li)

      integer, intent(in) :: law
      type(limb_t)        :: li

      ! Construct the limb_t from the supplied data

      select case (law)
      case (LINEAR_LAW)
      case (QUAD_LAW)
      case (CLARET_LAW)
      case default
         @:ABORT(invalid law)
      end select

      li%law = law

      ! Finish

      return

   end function limb_t_

   !****

   function n_basis (self)

      class(limb_t), intent(in) :: self
      integer                   :: n_basis

      ! Return the number of basis functions

      select case (self%law)
      case (LINEAR_LAW)
         n_basis = 2
      case (QUAD_LAW)
         n_basis = 3
      case (CLARET_LAW)
         n_basis = 5
      case default
         @:ABORT(invalid law)
      end select

      ! Finish

      return

   end function n_basis

   !****

   function intensity_basis(self, mu) result (b)

      class(limb_t), intent(in) :: self
      real(RD), intent(in)      :: mu
      real(RD), allocatable     :: b(:)

      ! Construct the intensity basis functions

      select case (self%law)
      case (LINEAR_LAW)
         b = [           &
              1._RD,     &
              mu - 1._RD &
              ]
      case (QUAD_LAW)
         b = [              &
              1._RD,        &
              mu - 1._RD,   &
              mu**2 - 1._RD &
              ]
      case (CLARET_LAW)
         b = [                     &
              1._RD,               &
              sqrt(mu) - 1._RD,    &
              mu - 1._RD,          &
              sqrt(mu)*mu - 1._RD, &
              mu**2 - 1._RD        &
              ]
      case default
         @:ABORT(invalid law)
      end select

      ! Finish

      return

   end function intensity_basis

   !****

   function D_moment_basis(self, l) result (b)

      class(limb_t), intent(in) :: self
      integer, intent(in)       :: l
      real(RD), allocatable     :: b(:)

      ! Evaluate the D-moment basis functions

      select case (self%law)
      case (LINEAR_LAW)
         b = [                                &
              D_ls(l, 1._RD),                 &
              D_ls(l, 2._RD) - D_ls(l, 1._RD) &
              ]
      case (QUAD_LAW)
         b = [                                 &
              D_ls(l, 1._RD),                  &
              D_ls(l, 2._RD) - D_ls(l, 1._RD), &
              D_ls(l, 3._RD) - D_ls(l, 1._RD)  &
              ]
      case (CLARET_LAW)
         b = [                                  &
              D_ls(l, 1._RD),                   &
              D_ls(l, 1.5_RD) - D_ls(l, 1._RD), &
              D_ls(l, 2._RD) - D_ls(l, 1._RD),  &
              D_ls(l, 2.5_RD) - D_ls(l, 1._RD), &
              D_ls(l, 3._RD) - D_ls(l, 1._RD)   &
              ]
      case default
         @:ABORT(invalid law)
      end select

      ! Finish

      return

   end function D_moment_basis

   !****

   function flux_basis(self) result (b)

      class(limb_t), intent(in) :: self
      real(RD), allocatable     :: b(:)

      ! Evaluate the flux basis functions

      select case (self%law)
      case (LINEAR_LAW)
         b = TWOPI*[       &
              1._RD/2._RD, &
              -1._RD/6._RD &
              ]
      case (QUAD_LAW)
         b = [              &
              -1._RD/2._RD, &
              -1._RD/6._RD, &
              -1._RD/4._RD  &
              ]
      case (CLARET_LAW)
         b = [               &
              1._RD/2._RD,   &
              -1._RD/10._RD, &
              -1._RD/6._RD,  &
              -3._RD/14._RD, &
              -1._RD/4._RD   &
              ]
      case default
         @:ABORT(invalid law)
      end select

      ! Finish

      return

   end function flux_basis

   !****

   function D_ls(l, s)

      integer, intent(in)  :: l
      real(RD), intent(in) :: s
      real(RD)             :: D_ls

      integer :: l_0
      integer :: m

      ! Evaluate the integral mu^s Pl(mu) from 0 to 1, using the
      ! expressions (42-44) from Townsend (2003)

      l_0 = MOD(l, 2)

      D_ls = 1._RD/(1._RD + s + l_0)

      do m = l_0+2, l, 2
         D_ls = (s - m)/(s + m + 3._RD)*D_ls
      end do

      ! Finish

      return

   end function D_ls

   !****

   subroutine fit_intensity_0_ (self, I, mu, c)

      class(limb_t), intent(in)          :: self
      real(RD), intent(in)               :: I(:)
      real(RD), intent(in)               :: mu(:)
      real(RD), allocatable, intent(out) :: c(:)

      real(RD), allocatable :: I_(:,:)
      real(RD), allocatable :: c_(:,:)

      ! Fit the limb-darkening law to the intensity data

      allocate(I_(SIZE(I), 1))

      I_(:,1) = I

      call self%fit_intensity(I_, mu, c_)

      c = c_(:,1)

      ! Finish

      return

   end subroutine fit_intensity_0_

   !****

   subroutine fit_intensity_1_ (self, I, mu, c)

      class(limb_t), intent(in)          :: self
      real(RD), intent(in)               :: I(:,:)
      real(RD), intent(in)               :: mu(:)
      real(RD), allocatable, intent(out) :: c(:,:)

      integer               :: n_mu
      integer               :: n_k
      integer               :: k
      real(RD)              :: y(SIZE(I, 1),SIZE(I, 2))
      integer               :: n_b
      real(RD), allocatable :: a(:,:)
      
      @:CHECK_BOUNDS(SIZE(I, 1), SIZE(mu))

      ! Fit the limb-darkening law to the intensity data

      ! Set up the fit data

      n_mu = SIZE(I, 1)
      n_k = SIZE(I, 2)

      y_loop : do k = 1, n_k
         y(:,k) = 1._RD - I(:,k)/I(n_mu,k)
      end do y_loop

      ! Fit the a-coefficients

      n_b = self%n_basis()

      allocate(a(n_b-1,n_k))

      call gls_fit(mu, y, f_, a)

      ! Tranform to c-coefficients

      allocate(c(n_b,n_k))

      c_loop : do k = 1, n_k
         c(1,k) = I(n_mu,k)
         c(2:,k) = -I(n_mu,k)*a(:,k)
      end do c_loop

      ! Finish

      return

   contains

      function f_ (mu, n)

         real(RD), intent(in) :: mu
         integer, intent(in)  :: n
         real(RD)             :: f_(n)

         f_ = self%intensity_basis(mu)

      end function f_

   end subroutine fit_intensity_1_

   !****
      
   subroutine read_(hi, li)

      type(hdf5io_t), intent(inout) :: hi
      type(limb_t), intent(out)     :: li

      character(TYPE_LEN) :: type
      integer             :: law

      ! Read the limb_t

      call hi%read_attr('TYPE', type)
      @:ASSERT(type == 'limb_t',invalid type)

      call hi%read_attr('law', law)
  
      li = limb_t(law)

      ! Finish

      return

   end subroutine read_

   !****

   subroutine write_ (hi, li)

      type(hdf5io_t), intent(inout) :: hi
      type(limb_t), intent(in)      :: li

      ! Write the limb_t

      call hi%write_attr('TYPE', 'limb_t')
      
      call hi%write_attr('law', li%law)

      ! Finish

      return

   end subroutine write_

end module limb_m
