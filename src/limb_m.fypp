! Module  : limb_m
! Purpose : define limb_t type, representing limb-darkening laws
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module limb_m

   ! Uses

   use kinds_m
   use hdf5io_m

   use const_m
   use fit_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Parameter definitions

   integer, parameter :: LINEAR_LAW = 1
   integer, parameter :: QUAD_LAW = 2
   integer, parameter :: CLARET_LAW = 3

   ! Derived-type definitions

   type limb_t
      private
      integer, public :: law
   contains
      private
      procedure         :: op_eql_li_li_
      generic, public   :: operator(==) => op_eql_li_li_
      procedure, public :: n_basis
      procedure, public :: intensity_basis
      procedure, public :: flux_basis
      procedure         :: intensity_0_
      procedure         :: intensity_1_
      generic, public   :: intensity => intensity_0_, intensity_1_
      procedure         :: flux_0_
      procedure         :: flux_1_
      generic, public   :: flux => flux_0_, flux_1_
      procedure         :: fit_intensity_0_
      procedure         :: fit_intensity_1_
      generic, public   :: fit_intensity => fit_intensity_0_, fit_intensity_1_
   end type limb_t

   ! Interfaces

   interface limb_t
      module procedure limb_t_
   end interface limb_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: LINEAR_LAW
   public :: QUAD_LAW
   public :: CLARET_LAW
   public :: limb_t
   public :: read
   public :: write

   ! Procedures

contains

   function limb_t_(law) result (li)

      integer, intent(in) :: law
      type(limb_t)        :: li

      ! Construct the limb_t from the supplied data

      select case (law)
      case (LINEAR_LAW)
      case (QUAD_LAW)
      case (CLARET_LAW)
      case default
         @:ABORT(invalid law)
      end select

      li%law = law

      ! Finish

      return

   end function limb_t_

   !****

   function op_eql_li_li_(self, other) result (eql)

      class(limb_t), intent(in) :: self
      type(limb_t), intent(in)  :: other
      logical                   :: eql

      ! See if the limb_t's are equal

      eql = self%law == other%law

      ! Finish

      return

   end function op_eql_li_li_

   !****

   subroutine read_(hi, li)

      type(hdf5io_t), intent(inout) :: hi
      type(limb_t), intent(out)     :: li

      character(TYPE_LEN) :: type
      integer             :: law

      ! Read the limb_t

      call hi%read_attr('TYPE', type)
      @:ASSERT(type == 'limb_t',invalid type)

      call hi%read_attr('law', law)
  
      li = limb_t(law)

      ! Finish

      return

   end subroutine read_

   !****

   subroutine write_ (hi, li)

      type(hdf5io_t), intent(inout) :: hi
      type(limb_t), intent(in)      :: li

      ! Write the limb_t

      call hi%write_attr('TYPE', 'limb_t')
      
      call hi%write_attr('law', li%law)

      ! Finish

      return

   end subroutine write_

   !****

   function n_basis (self)

      class(limb_t), intent(in) :: self
      integer                   :: n_basis

      ! Return the basis dimension

      select case (self%law)
      case (LINEAR_LAW)
         n_basis = 1
      case (QUAD_LAW)
         n_basis = 2
      case (CLARET_LAW)
         n_basis = 4
      case default
         @:ABORT(invalid law)
      end select

      ! Finish

      return

   end function n_basis

   !****

   function intensity_basis(self, mu) result (b)

      class(limb_t), intent(in) :: self
      real(RD), intent(in)      :: mu
      real(RD), allocatable     :: b(:)

      ! Construct the intensity basis vector

      select case (self%law)
      case (LINEAR_LAW)
         b = [           &
              1._RD - mu &
              ]
      case (QUAD_LAW)
         b = [              &
              1._RD - mu,   &
              1._RD - mu*mu &
              ]
      case (CLARET_LAW)
         b = [                     &
              1._RD - sqrt(mu),    &
              1._RD - mu,          &
              1._RD - sqrt(mu)*mu, &
              1._RD - mu*mu        &
              ]
      case default
         @:ABORT(invalid law)
      end select

      ! Finish

      return

   end function intensity_basis

   !****

   function flux_basis(self) result (b)

      class(limb_t), intent(in) :: self
      real(RD), allocatable     :: b(:)

      ! Construct the flux basis vector

      select case (self%law)
      case (LINEAR_LAW)
         b = [            &
              1._RD/6._RD &
              ]
      case (QUAD_LAW)
         b = [             &
              1._RD/6._RD, &
              1._RD/4._RD  &
              ]
      case (CLARET_LAW)
         b = [              &
              1._RD/10._RD, &
              1._RD/6._RD,  &
              3._RD/14._RD, &
              1._RD/4._RD   &
              ]
      case default
         @:ABORT(invalid law)
      end select

      ! Finish

      return

   end function flux_basis

   !****

   #:for rank in (0, 1)

      function intensity_${rank}$_(self, I_1, a, mu) result(I)

         class(limb_t), intent(in) :: self
         real(RD), intent(in)      :: I_1${ARRAY_SPEC(rank)}$
         real(RD), intent(in)      :: a${ARRAY_SPEC(rank+1)}$
         real(RD), intent(in)      :: mu
         real(RD)                  :: I${ARRAY_SPEC(rank, 'SIZE(I_1, {0:d})')}$

         real(RD), allocatable :: b(:)

         #:if rank == 1
            @:CHECK_BOUNDS(SIZE(a, 1), self%n_basis())
            @:CHECK_BOUNDS(SIZE(a, 2), SIZE(I_1))
         #:endif

         ! Evaluate the intensity

         b = self%intensity_basis(mu)

         #:if rank == 1
            I = I_1*(1._RD - MATMUL(b, a))
         #:else
            I = I_1*(1._RD - DOT_PRODUCT(b, a))
         #:endif

         ! Finish

         return

      end function intensity_${rank}$_

   #:endfor

   !****

   #:for rank in (0, 1)

      function flux_${rank}$_(self, I_1, a) result(F)

         class(limb_t), intent(in) :: self
         real(RD), intent(in)      :: I_1${ARRAY_SPEC(rank)}$
         real(RD), intent(in)      :: a${ARRAY_SPEC(rank+1)}$
         real(RD)                  :: F${ARRAY_SPEC(rank, 'SIZE(I_1, {0:d})')}$

         real(RD), allocatable :: b(:)

         #:if rank == 1
            @:CHECK_BOUNDS(SIZE(a, 1), self%n_basis())
            @:CHECK_BOUNDS(SIZE(a, 2), SIZE(I_1))
         #:endif
            
         ! Evaluate the flux

         b = self%flux_basis()

         #:if rank == 1
            F = I_1*TWOPI*(0.5_RD - MATMUL(b, a))
         #:else
            F = I_1*TWOPI*(0.5_RD - DOT_PRODUCT(b, a))
         #:endif

         ! Finish

         return

      end function flux_${rank}$_

   #:endfor

   !****

   subroutine fit_intensity_0_ (self, I, mu, I_1, a)

      class(limb_t), intent(in)          :: self
      real(RD), intent(in)               :: I(:)
      real(RD), intent(in)               :: mu(:)
      real(RD), intent(out)              :: I_1
      real(RD), allocatable, intent(out) :: a(:)

      real(RD), allocatable :: I_(:,:)
      real(RD), allocatable :: I_1_(:)
      real(RD), allocatable :: a_(:,:)

      ! Fit the limb-darkening law to the intensity data

      allocate(I_(SIZE(I), 1))

      I_(:,1) = I

      call self%fit_intensity(I_, mu, I_1_, a_)

      I_1 = I_1_(1)
      a = a_(:,1)

      ! Finish

      return

   end subroutine fit_intensity_0_

   !****

   subroutine fit_intensity_1_ (self, I, mu, I_1, a)

      class(limb_t), intent(in)          :: self
      real(RD), intent(in)               :: I(:,:)
      real(RD), intent(in)               :: mu(:)
      real(RD), allocatable, intent(out) :: I_1(:)
      real(RD), allocatable, intent(out) :: a(:,:)

      integer               :: n_mu
      integer               :: n_w
      real(RD), allocatable :: y(:,:)
      integer               :: k
      integer               :: n_b
      
      @:CHECK_BOUNDS(SIZE(I, 1), SIZE(mu))

      ! Fit the limb-darkening law to the intensity data

      ! Store the normal intensity

      n_mu = SIZE(I, 1)
      n_w = SIZE(I, 2)

      I_1 = I(n_mu,:)

      ! Set up the fit data

      allocate(y(n_mu,n_w))

      w_loop : do k = 1, n_w
         y(:,k) = 1._RD - I(:,k)/I_1(k)
      end do w_loop

      ! Do the fit

      n_b = self%n_basis()

      allocate(a(n_b,n_w))

      call gls_fit(mu, y, f_, a)

      ! Finish

      return

   contains

      function f_ (mu, n)

         real(RD), intent(in) :: mu
         integer, intent(in)  :: n
         real(RD)             :: f_(n)

         f_ = self%intensity_basis(mu)

      end function f_

   end subroutine fit_intensity_1_

   !****
      
end module limb_m
