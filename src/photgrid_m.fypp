! Module  : photgrid_m
! Purpose : define photgrid_t type, for representing spectral intensity
!           grids
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module photgrid_m

   ! Uses
   
   use kinds_m
   use hdf5io_m

   use grid_m
   use photint_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type :: photgrid_t
      private
      type(photint_t), allocatable :: pi(:,:)
      type(grid_t)                 :: gr
      integer                      :: n_logT
      integer                      :: n_logg
   contains
      private
      procedure, public :: inquire
      #:for name in ('intensity', 'D_moment', 'flux')
         procedure, public :: interp_${name}$
      #:endfor
   end type photgrid_t

   ! Interfaces

   interface photgrid_t
      module procedure photgrid_t_
   end interface photgrid_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access photifiers

   private

   public :: photgrid_t
   public :: read
   public :: write

   ! Procedures

contains

   function photgrid_t_ (pi, gr) result (pg)

      type(photint_t), intent(in) :: pi(:,:)
      type(grid_t), intent(in)    :: gr
      type(photgrid_t)            :: pg

      integer :: n_logT
      integer :: n_logg

      ! Construct the photgrid_t

      call gr%inquire(n_logT=n_logT, n_logg=n_logg)

      @:CHECK_BOUNDS(SIZE(pi, 1), n_logT)
      @:CHECK_BOUNDS(SIZE(pi, 2), n_logg)
 
      pg%pi = pi

      pg%gr = gr

      pg%n_logT = n_logT
      pg%n_logg = n_logg

      ! Finish

      return

   end function photgrid_t_

   !****

   subroutine inquire(self, n_logT, n_logg)

      class(photgrid_t), intent(in)  :: self
      integer, intent(out), optional :: n_logT
      integer, intent(out), optional :: n_logg

      ! Inquire metadata

      if (PRESENT(n_logT)) n_logT = self%n_logT
      if (PRESENT(n_logg)) n_logg = self%n_logg

      ! Finish

      return

   end subroutine inquire

   !****

   #:for name, var, arg_var, arg_type in (('intensity', 'I', 'mu', 'real(RD)'), &
                                          ('D_moment', 'D', 'l', 'integer'))

      subroutine interp_${name}$(self, logT, logg, ${arg_var}$, ${var}$, stat, d_dlogT, d_dlogg)

         class(photgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: logT
         real(RD), intent(in)             :: logg
         ${arg_type}$, intent(in)         :: ${arg_var}$
         real(RD), intent(out)            :: ${var}$
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: d_dlogT
         logical, intent(in), optional    :: d_dlogg

         ! Interpolate the ${name}$

         call self%gr%interp(proc_, logT, logg, ${var}$, stat, d_dlogT, d_dlogg)

         ! Finish

      contains

         subroutine proc_(i, j, f, stat)

            integer, intent(in)            :: i
            integer, intent(in)            :: j
            real(RD), intent(out)          :: f
            integer, intent(out), optional :: stat

            call self%pi(i,j)%interp_${name}$(${arg_var}$, f, stat)

            return

         end subroutine proc_

      end subroutine interp_${name}$

   #:endfor

   !****

   #:for name, var in (('flux', 'F'), )

      subroutine interp_${name}$(self, logT, logg, ${var}$, stat, d_dlogT, d_dlogg)

         class(photgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: logT
         real(RD), intent(in)             :: logg
         real(RD), intent(out)            :: ${var}$
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: d_dlogT
         logical, intent(in), optional    :: d_dlogg

         ! Interpolate the ${name}$

         call self%gr%interp(proc_, logT, logg, ${var}$, stat, d_dlogT, d_dlogg)

         ! Finish

      contains

         subroutine proc_(i, j, f, stat)

            integer, intent(in)            :: i
            integer, intent(in)            :: j
            real(RD), intent(out)          :: f
            integer, intent(out), optional :: stat

            call self%pi(i,j)%interp_${name}$(f, stat)

            return

         end subroutine proc_

      end subroutine interp_${name}$

   #:endfor

   !****

   subroutine read_(hi, pg)

      type(hdf5io_t), intent(inout) :: hi
      type(photgrid_t), intent(out) :: pg

      character(TYPE_LEN)          :: file_type
      integer                      :: n_logT
      integer                      :: n_logg
      type(hdf5io_t)               :: hi_gr
      type(grid_t)                 :: gr
      type(photint_t), allocatable :: pi(:,:)
      
      ! Read the photgrid_t

      call hi%read_attr('TYPE', file_type)
      @:ASSERT(file_type == 'specgrid_t', invalid type)
      
      call hi%read_attr('n_logT', n_logT)
      call hi%read_attr('n_logg', n_logg)

      hi_gr = hdf5io_t(hi, 'gr')
      call read(hi_gr, gr)
      call hi_gr%final()

      allocate(pi(n_logT,n_logg))

      call gr%map(read_photint_)

      pg = photgrid_t(pi, gr)

      ! Finish

      return

   contains

      subroutine read_photint_(i, j, stat)

         integer, intent(in)            :: i
         integer, intent(in)            :: j
         integer, intent(out), optional :: stat

         type(hdf5io_t) :: hi_pi

         ! Read the photint_t
 
         hi_pi = hdf5io_t(hi, pi_name_(i,j))
         call read(hi_pi, pi(i,j))
         call hi_pi%final()

         ! Finish

         return

      end subroutine read_photint_

   end subroutine read_

   !****

   subroutine write_(hi, pg)

      type(hdf5io_t), intent(inout) :: hi
      type(photgrid_t), intent(in)  :: pg

      type(hdf5io_t) :: hi_gr

      ! Write the photgrid_t

      call hi%write_attr('TYPE', 'photgrid_t')

      call hi%write_attr('n_logT', pg%n_logT)
      call hi%write_attr('n_logg', pg%n_logg)

      hi_gr = hdf5io_t(hi, 'gr')
      call write(hi_gr, pg%gr)
      call hi_gr%final()

      call pg%gr%map(write_photint_)

      ! Finish

      return

   contains
 
      subroutine write_photint_(i, j, stat)

         integer, intent(in)            :: i
         integer, intent(in)            :: j
         integer, intent(out), optional :: stat

         type(hdf5io_t) :: hi_pi

         ! Write the photint_t for the node
 
         hi_pi = hdf5io_t(hi, pi_name_(i,j))
         call write(hi_pi, pg%pi(i,j))
         call hi_pi%final()

         ! Finish

         return

      end subroutine write_photint_

   end subroutine write_

   !****

   function pi_name_(i,j) result (name)

      integer, intent(in) :: i
      integer, intent(in) :: j
      character(256)      :: name

      write(name, 100) i, j
100   format('pi(',I0,',',I0,')')

   end function pi_name_

end module photgrid_m
