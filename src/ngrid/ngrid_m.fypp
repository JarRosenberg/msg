! Module  : ngrid_m
! Purpose : define ngrid_t type, a simple base type for N-dimensional
!           interpolating grids
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module ngrid_m

   ! Uses
   
   use forum_m, locate_ => locate

   use axis_m
   use ncubic_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type ngrid_t
      private
      type(axis_t), allocatable :: ax(:)
      logical, allocatable      :: mask(:)
      integer, allocatable      :: shape(:)
      integer, allocatable      :: li_ci(:)
      integer, allocatable      :: ci_li(:)
      integer                   :: rank
      integer                   :: n_ci
      integer                   :: n_li
      integer                   :: n_si
   contains
      private
      procedure, public :: inquire
      procedure, public :: locate
      procedure, public :: map
      procedure, public :: ci_from_li
      procedure, public :: li_from_ci
      procedure, public :: li_from_vi
      procedure, public :: vi_from_li
      procedure         :: vi_from_si_
      procedure         :: interp_0_
      procedure         :: interp_1_
      generic, public   :: interp => interp_0_, interp_1_
      procedure         :: setup_interp_
   end type ngrid_t

   ! Interfaces

   interface ngrid_t
      module procedure ngrid_t_
   end interface ngrid_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: ngrid_t
   public :: read
   public :: write

   ! Procedures

contains

   function ngrid_t_ (ax, mask) result (ng)

      type(axis_t), intent(in) :: ax(:)
      logical, intent(in)      :: mask(:)
      type(ngrid_t)            :: ng

      integer :: rank
      integer :: j
      integer :: shape(SIZE(ax))
      integer :: ci
      integer :: li

      ! Construct the ngrid_t

      rank = SIZE(ax)

      do j = 1, rank
         call ax(j)%inquire(n=shape(j))
      end do

      @:CHECK_BOUNDS(SIZE(mask), PRODUCT(shape))

      ng%mask = mask
      ng%ax = ax

      ng%shape = shape
      ng%rank = rank

      ng%n_ci = COUNT(mask)
      ng%n_li = SIZE(mask)

      ng%ci_li = UNPACK([(ci, ci=1,ng%n_ci)], mask, 0)
      ng%li_ci = PACK([(li, li=1,ng%n_li)], ng%ci_li /= 0)

      ng%n_si = 4**rank

      ! Finish

      return

   end function ngrid_t_

   !****

   subroutine inquire(self, n_ci, n_li, shape, rank, axis_min, axis_max, axis_labels)

      class(ngrid_t), intent(in)          :: self
      integer, intent(out), optional      :: n_ci
      integer, intent(out), optional      :: n_li
      integer, intent(out), optional      :: shape(:)
      integer, intent(out), optional      :: rank
      real(RD), intent(out), optional     :: axis_min(:)
      real(RD), intent(out), optional     :: axis_max(:)
      character(*), intent(out), optional :: axis_labels(:)

      integer :: j

      if (PRESENT(shape)) then
         @:CHECK_BOUNDS(SIZE(shape), self%rank)
      end if

      if (PRESENT(axis_min)) then
         @:CHECK_BOUNDS(SIZE(axis_min), self%rank)
      end if

      if (PRESENT(axis_max)) then
         @:CHECK_BOUNDS(SIZE(axis_max), self%rank)
      end if

      if (PRESENT(axis_labels)) then
         @:CHECK_BOUNDS(SIZE(axis_labels), self%rank)
      end if

      ! Inquire metadata

      if (PRESENT(n_ci)) n_ci = self%n_ci
      if (PRESENT(n_li)) n_li = self%n_li

      if (PRESENT(shape)) shape = self%shape
      if (PRESENT(rank)) rank = self%rank

      if (PRESENT(axis_min)) then
         do j = 1, self%rank
            call self%ax(j)%inquire(min=axis_min(j))
         end do
      end if

      if (PRESENT(axis_max)) then
         do j = 1, self%rank
            call self%ax(j)%inquire(max=axis_max(j))
         end do
      end if

      if (PRESENT(axis_labels)) then
         do j = 1, self%rank
            call self%ax(j)%inquire(label=axis_labels(j))
         end do
      end if

      ! Finish

      return

   end subroutine inquire

   !****

   subroutine locate(self, vx, vi, stat)

      class(ngrid_t), intent(in)     :: self
      real(RD), intent(in)           :: vx(:)
      integer, intent(out)           :: vi(:)
      integer, intent(out), optional :: stat

      integer              :: j
      character(LABEL_LEN) :: label

      @:CHECK_BOUNDS(SIZE(vx), self%rank)
      @:CHECK_BOUNDS(SIZE(vi), self%rank)

      ! Locate vx in the grid

      do j = 1, self%rank

         call self%ax(j)%locate(vx(j), vi(j))

         if (vi(j) < 1) then
            if (PRESENT(stat)) then
               stat = STAT_OUT_OF_BOUNDS_AXIS_LO
               return
            else
               call self%ax(j)%inquire(label=label)
               @:ABORT('out-of-bounds (lo) on '//label//' axis')
            endif
         endif

         if (vi(j) > self%shape(j)) then
            if (PRESENT(stat)) then
               stat = STAT_OUT_OF_BOUNDS_AXIS_HI
               return
            else
               call self%ax(j)%inquire(label=label)
               @:ABORT('out-of-bounds (hi) on '//label//' axis')
            endif
         endif

      end do

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine locate

   !****

   subroutine map(self, map_proc, stat)

      class(ngrid_t), intent(in) :: self
      interface
         subroutine map_proc(vi, stat)
            use forum_m
            integer, intent(in)            :: vi(:)
            integer, intent(out), optional :: stat
         end subroutine map_proc
      end interface
      integer, intent(out), optional :: stat

      integer :: li
      integer :: vi(self%rank)

      ! Apply the map_proc function to each unmasked node in the grid

      map_loop : do li = 1, self%n_li

         if (self%mask(li)) then

            vi = self%vi_from_li(li)

            call map_proc(vi, stat)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            end if

         end if

      end do map_loop

      ! Finish

      return

   end subroutine map

   !****

   function ci_from_li(self, li) result(ci)

      class(ngrid_t), intent(in) :: self
      integer, intent(in)        :: li
      integer                    :: ci

      ! Calculate a contiguous index from a linear index

      ci = self%ci_li(li)

      ! Finish

      return

   end function ci_from_li

   !****

   function li_from_ci(self, ci) result(li)

      class(ngrid_t), intent(in) :: self
      integer, intent(in)        :: ci
      integer                    :: li

      ! Calculate a linear index from a contiguous index

      li = self%li_ci(ci)

      ! Finish

      return

   end function li_from_ci

   !****

   function li_from_vi(self, vi) result(li)

      class(ngrid_t), intent(in) :: self
      integer, intent(in)        :: vi(:)
      integer                    :: li

      integer :: p
      integer :: j

      @:CHECK_BOUNDS(SIZE(vi), self%rank)

      ! Calculate a linear index from a vector index

      p = 1
      li = vi(1)

      do j = 2, self%rank
         p = p*self%shape(j-1)
         li = li + (vi(j)-1)*p
      end do

      ! Finish

      return

   end function li_from_vi

   !****

   function vi_from_li(self, li) result(vi)

      class(ngrid_t), intent(in) :: self
      integer, intent(in)        :: li
      integer                    :: vi(self%rank)

      integer :: p
      integer :: r
      integer :: j

      ! Calculate a vector index from a linear index

      p = self%n_li
      r = li - 1

      do j = self%rank, 1, -1
         p = p/self%shape(j)
         vi(j) = r/p + 1
         r = r - (vi(j)-1)*p
      end do

      @:ASSERT_DEBUG(li == self%li_from_vi(vi), 'indexing error')

      ! Finish

      return

   end function vi_from_li

   !****

   function vi_from_si_(self, vi_cl, si) result(vi)

      class(ngrid_t), intent(in) :: self
      integer, intent(in)        :: vi_cl(:)
      integer, intent(in)        :: si
      integer                    :: vi(self%rank)

      integer :: p
      integer :: r
      integer :: j

      @:CHECK_BOUNDS(SIZE(vi_cl), self%rank)

      ! Calculate a vector index from a stencil index

      p = self%n_si
      r = si - 1

      do j = self%rank, 1, -1
         p = p/4
         vi(j) = r/p + 1
         r = r - (vi(j)-1)*p
      end do

      vi = vi + vi_cl - 2

      @:ASSERT_DEBUG(ALL(vi >= vi_cl-1 .AND. vi <= vi_cl+2), 'indexing error')

      ! Finish

      return

   end function vi_from_si_

   !****

   subroutine interp_0_(self, data_proc, vx, f_int, stat, vderiv)

      class(ngrid_t), intent(in) :: self
      interface
         subroutine data_proc(vi, data, stat)
            use forum_m
            integer, intent(in)            :: vi(:)
            real(RD), intent(out)          :: data
            integer, intent(out), optional :: stat
         end subroutine data_proc
      end interface
      real(RD), intent(in)           :: vx(:)
      real(RD), intent(out)          :: f_int
      integer, intent(out), optional :: stat
      logical, intent(in), optional  :: vderiv(:)

      integer  :: vi_cl(self%rank)
      logical  :: mask(self%n_si)
      real(RD) :: vdelta(3,self%rank)
      real(RD) :: vu(self%rank)
      real(RD) :: K(self%n_si,self%n_si)
      integer  :: si
      integer  :: vi(self%rank)
      real(RD) :: F(self%n_si)
      real(RD) :: C(self%n_si)

      @:CHECK_BOUNDS(SIZE(vx), self%rank)

      ! Interpolate a scalar value

      ! Set up the interpolation

      call self%setup_interp_(vx, vi_cl, mask, vdelta, vu, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      ! Evaluate the kernel

      call eval_kernel(self%rank, mask, vdelta, K, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      ! Evaluate data at the nodes

      do si = 1, self%n_si

         if (ANY(K(:,si) /= 0._RD)) then

            vi = self%vi_from_si_(vi_cl, si)

            call data_proc(vi, F(si), stat)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            endif

         else

            F(si) = 0._RD

         endif

      end do

      ! Evaluate the C vector

      C = MATMUL(K, F)

      ! Perform the interpolation

      call interp_ncubic(self%rank, vu, C, vdelta, f_int, vderiv)

      if (PRESENT(stat)) stat = STAT_OK

      ! Finish

      return

   end subroutine interp_0_

   !****

   subroutine interp_1_(self, data_proc, vx, f_int, stat, vderiv)

      class(ngrid_t), intent(in) :: self
      interface
         subroutine data_proc(vi, data, stat)
            use forum_m
            integer, intent(in)            :: vi(:)
            real(RD), intent(out)          :: data(:)
            integer, intent(out), optional :: stat
         end subroutine data_proc
      end interface
      real(RD), intent(in)           :: vx(:)
      real(RD), intent(out)          :: f_int(:)
      integer, intent(out), optional :: stat
      logical, intent(in), optional  :: vderiv(:)

      integer               :: vi_cl(self%rank)
      logical               :: mask(self%n_si)
      real(RD)              :: vdelta(3,self%rank)
      real(RD)              :: vu(self%rank)
      real(RD)              :: K(self%n_si,self%n_si)
      integer               :: n_m
      integer               :: si
      integer               :: vi(self%rank)
      real(RD), allocatable :: F(:,:)
      real(RD)              :: C(self%n_si)
      integer               :: m

      @:CHECK_BOUNDS(SIZE(vx), self%rank)

      ! Interpolate an array value

      ! Set up the interpolation

      call self%setup_interp_(vx, vi_cl, mask, vdelta, vu, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      ! Evaluate the kernel

      call eval_kernel(self%rank, mask, vdelta, K, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      ! Evaluate data at the nodes

      n_m = SIZE(f_int)

      allocate(F(self%n_si,n_m))

      do si = 1, self%n_si

         if (ANY(K(:,si) /= 0._RD)) then

            vi = self%vi_from_si_(vi_cl, si)

            call data_proc(vi, F(si,:), stat)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            endif

         else

            F(si,:) = 0._RD

         endif

      end do

      ! Now loop through output points

      !$OMP PARALLEL DO PRIVATE(C)
      do m = 1, n_m

         ! Evaluate the C vector

         C = MATMUL(K, F(:,m))

         ! Perform the interpolation

         call interp_ncubic(self%rank, vu, C, vdelta, f_int(m), vderiv)

      end do

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine interp_1_

   !****
   
   subroutine setup_interp_(self, vx, vi_cl, mask, vdelta, vu, stat)

      class(ngrid_t), intent(in)     :: self
      real(RD), intent(in)           :: vx(:)
      integer, intent(out)           :: vi_cl(:)
      logical, intent(out)           :: mask(:)
      real(RD), intent(out)          :: vdelta(:,:)
      real(RD), intent(out)          :: vu(:)
      integer, intent(out), optional :: stat

      integer  :: j
      integer  :: si
      integer  :: vi(self%rank)
      integer  :: li
      integer  :: l
      integer  :: i
      real(RD) :: x(4)

      @:CHECK_BOUNDS(SIZE(vx), self%rank)
      @:CHECK_BOUNDS(SIZE(vi_cl), self%rank)
      @:CHECK_BOUNDS(SIZE(mask), self%n_si)

      @:CHECK_BOUNDS(SIZE(vdelta, 1), 3)
      @:CHECK_BOUNDS(SIZE(vdelta, 2), self%rank)

      @:CHECK_BOUNDS(SIZE(vu), self%rank)

      ! Locate the interpolation cell

      call self%locate(vx, vi_cl, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      vi_cl = MIN(vi_cl, self%shape-1)

      ! Set up the mask

      do si = 1, self%n_si

         vi = self%vi_from_si_(vi_cl, si)

         mask(si) = .NOT. ANY(vi < 1 .OR. vi > self%shape)

         if (mask(si)) then
            li = self%li_from_vi(vi)
            mask(si) = mask(si) .AND. self%mask(li)
         end if

      end do

      ! Set up the vdelta and vu values

      do j = 1, self%rank

         do l = 1, 4

            i = vi_cl(j) + l - 2

            if (i < 1) then
               x(l) = -HUGE(0._RD)
            elseif (i > self%shape(j)) then
               x(l) = HUGE(0._RD)
            else
               call self%ax(j)%get(i, x(l))
            endif

         end do

         vdelta(:,j) = x(2:4) - x(1:3)

         vu(j) = (vx(j) - x(2))/vdelta(2,j)

      end do

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine setup_interp_

   !****

   subroutine read_(hi, ng, stat)

      type(hdf5io_t), intent(inout)  :: hi
      type(ngrid_t), intent(out)     :: ng
      integer, intent(out), optional :: stat

      character(TYPE_LEN)       :: type
      integer                   :: rank
      logical, allocatable      :: mask(:)
      type(axis_t), allocatable :: ax(:)
      integer                   :: j
      type(hdf5io_t)            :: hi_ax

      ! Read the ngrid_t

      call hi%read_attr('TYPE', type)
      if (type /= 'ngrid_t') then
         if (PRESENT(stat)) then
            stat = STAT_INVALID_TYPE
            return
         else
            @:ABORT('invalid type')
         endif
      endif

      call hi%read_attr('rank', rank)

      allocate(ax(rank))

      ax_loop : do j = 1, rank
         hi_ax = hdf5io_t(hi, ax_name_(j))
         call read(hi_ax, ax(j), stat)
         call hi_ax%final()
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif
      end do ax_loop

      call hi%alloc_read_dset('mask', mask)

      ng = ngrid_t(ax, mask)

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine read_

   !****

   subroutine write_(hi, ng, stat)

      type(hdf5io_t), intent(inout)  :: hi
      type(ngrid_t), intent(in)      :: ng
      integer, intent(out), optional :: stat

      integer        :: j
      type(hdf5io_t) :: hi_ax

      ! Write the ngrid_t
      
      call hi%write_attr('TYPE', 'ngrid_t')

      call hi%write_attr('shape', ng%shape)
      call hi%write_attr('rank', ng%rank)

      do j = 1, ng%rank
         hi_ax = hdf5io_t(hi, ax_name_(j))
         call write(hi_ax, ng%ax(j), stat)
         call hi_ax%final()
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif
      end do

      call hi%write_dset('mask', ng%mask)

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine write_

   !****

   function ax_name_(j) result (name)

      integer, intent(in) :: j
      character(256)      :: name

      write(name, 100) j
100   format('ax(',I0,')')

   end function ax_name_

end module ngrid_m
