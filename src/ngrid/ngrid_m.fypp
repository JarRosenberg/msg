! Module  : ngrid_m
! Purpose : define ngrid_t type, a simple base type for N-dimensional
!           interpolating grids
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module ngrid_m

   ! Uses
   
   use forum_m, locate_ => locate

   use axis_m
   use ncubic_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type ngrid_t
      private
      type(axis_t), allocatable :: axes(:)
      logical, allocatable      :: mask(:)
      integer, allocatable      :: shape(:)
      integer, allocatable      :: lin_con(:)
      integer, allocatable      :: con_lin(:)
      integer                   :: rank
      integer                   :: n_con
      integer                   :: n_lin
      integer                   :: n_stn
   contains
      private
      procedure, public :: inquire
      procedure, public :: locate
      procedure, public :: map
      procedure, public :: con_from_lin
      procedure, public :: lin_from_con
      procedure, public :: lin_from_vec
      procedure, public :: vec_from_lin
      procedure         :: vec_from_stn_
      procedure         :: interp_0_
      procedure         :: interp_1_
      generic, public   :: interp => interp_0_, interp_1_
      procedure         :: setup_interp_
      procedure, public :: read
      procedure, public :: write
   end type ngrid_t

   ! Interfaces

   interface ngrid_t
      module procedure ngrid_t_
   end interface ngrid_t

   ! Access specifiers

   private

   public :: ngrid_t

   ! Procedures

contains

   function ngrid_t_ (axes, mask) result(ngrid)

      type(axis_t), intent(in) :: axes(:)
      logical, intent(in)      :: mask(:)
      type(ngrid_t)            :: ngrid

      integer :: rank
      integer :: j
      integer :: shape(SIZE(axes))
      integer :: i_con
      integer :: i_lin

      ! Construct ngrid from the supplied data

      rank = SIZE(axes)

      do j = 1, rank
         call axes(j)%inquire(n=shape(j))
      end do

      @:CHECK_BOUNDS(SIZE(mask), PRODUCT(shape))

      ngrid%mask = mask
      ngrid%axes = axes

      ngrid%shape = shape
      ngrid%rank = rank

      ngrid%n_con = COUNT(mask)
      ngrid%n_lin = SIZE(mask)

      ngrid%con_lin = UNPACK([(i_con, i_con=1,ngrid%n_con)], mask, 0)
      ngrid%lin_con = PACK([(i_lin, i_lin=1,ngrid%n_lin)], ngrid%con_lin /= 0)

      ngrid%n_stn = 4**rank

      ! Finish

      return

   end function ngrid_t_

   !****

   subroutine inquire(self, n_con, n_lin, shape, rank, axis_min, axis_max, axis_labels)

      class(ngrid_t), intent(in)          :: self
      integer, intent(out), optional      :: n_con
      integer, intent(out), optional      :: n_lin
      integer, intent(out), optional      :: shape(:)
      integer, intent(out), optional      :: rank
      real(RD), intent(out), optional     :: axis_min(:)
      real(RD), intent(out), optional     :: axis_max(:)
      character(*), intent(out), optional :: axis_labels(:)

      integer :: j

      if (PRESENT(shape)) then
         @:CHECK_BOUNDS(SIZE(shape), self%rank)
      end if

      if (PRESENT(axis_min)) then
         @:CHECK_BOUNDS(SIZE(axis_min), self%rank)
      end if

      if (PRESENT(axis_max)) then
         @:CHECK_BOUNDS(SIZE(axis_max), self%rank)
      end if

      if (PRESENT(axis_labels)) then
         @:CHECK_BOUNDS(SIZE(axis_labels), self%rank)
      end if

      ! Inquire metadata

      if (PRESENT(n_con)) n_con = self%n_con
      if (PRESENT(n_lin)) n_lin = self%n_lin

      if (PRESENT(shape)) shape = self%shape
      if (PRESENT(rank)) rank = self%rank

      if (PRESENT(axis_min)) then
         do j = 1, self%rank
            call self%axes(j)%inquire(min=axis_min(j))
         end do
      end if

      if (PRESENT(axis_max)) then
         do j = 1, self%rank
            call self%axes(j)%inquire(max=axis_max(j))
         end do
      end if

      if (PRESENT(axis_labels)) then
         do j = 1, self%rank
            call self%axes(j)%inquire(label=axis_labels(j))
         end do
      end if

      ! Finish

      return

   end subroutine inquire

   !****

   subroutine locate(self, vx, i_vec, stat)

      class(ngrid_t), intent(in)     :: self
      real(RD), intent(in)           :: vx(:)
      integer, intent(out)           :: i_vec(:)
      integer, intent(out), optional :: stat

      integer              :: j
      character(LABEL_LEN) :: label

      @:CHECK_BOUNDS(SIZE(vx), self%rank)
      @:CHECK_BOUNDS(SIZE(i_vec), self%rank)

      ! Locate vx in the grid

      do j = 1, self%rank

         call self%axes(j)%locate(vx(j), i_vec(j))

         if (i_vec(j) < 1) then
            if (PRESENT(stat)) then
               stat = STAT_OUT_OF_BOUNDS_AXIS_LO
               return
            else
               call self%axes(j)%inquire(label=label)
               @:ABORT('out-of-bounds (lo) on '//label//' axis')
            endif
         endif

         if (i_vec(j) > self%shape(j)) then
            if (PRESENT(stat)) then
               stat = STAT_OUT_OF_BOUNDS_AXIS_HI
               return
            else
               call self%axes(j)%inquire(label=label)
               @:ABORT('out-of-bounds (hi) on '//label//' axis')
            endif
         endif

      end do

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine locate

   !****

   subroutine map(self, map_proc, stat)

      class(ngrid_t), intent(in) :: self
      interface
         subroutine map_proc(i_vec, stat)
            use forum_m
            integer, intent(in)            :: i_vec(:)
            integer, intent(out), optional :: stat
         end subroutine map_proc
      end interface
      integer, intent(out), optional :: stat

      integer :: i_lin
      integer :: i_vec(self%rank)

      ! Apply the map_proc function to each unmasked node in the grid

      map_loop : do i_lin = 1, self%n_lin

         if (self%mask(i_lin)) then

            i_vec = self%vec_from_lin(i_lin)

            call map_proc(i_vec, stat)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            end if

         end if

      end do map_loop

      ! Finish

      return

   end subroutine map

   !****

   function con_from_lin(self, i_lin) result(i_con)

      class(ngrid_t), intent(in) :: self
      integer, intent(in)        :: i_lin
      integer                    :: i_con

      ! Calculate a contiguous index from a linear index

      i_con = self%con_lin(i_lin)

      ! Finish

      return

   end function con_from_lin

   !****

   function lin_from_con(self, i_con) result(i_lin)

      class(ngrid_t), intent(in) :: self
      integer, intent(in)        :: i_con
      integer                    :: i_lin

      ! Calculate a linear index from a contiguous index

      i_lin = self%lin_con(i_con)

      ! Finish

      return

   end function lin_from_con

   !****

   function lin_from_vec(self, i_vec) result(i_lin)

      class(ngrid_t), intent(in) :: self
      integer, intent(in)        :: i_vec(:)
      integer                    :: i_lin

      integer :: p
      integer :: j

      @:CHECK_BOUNDS(SIZE(i_vec), self%rank)

      ! Calculate a linear index from a vector index

      p = 1
      i_lin = i_vec(1)

      do j = 2, self%rank
         p = p*self%shape(j-1)
         i_lin = i_lin + (i_vec(j)-1)*p
      end do

      ! Finish

      return

   end function lin_from_vec

   !****

   function vec_from_lin(self, i_lin) result(i_vec)

      class(ngrid_t), intent(in) :: self
      integer, intent(in)        :: i_lin
      integer                    :: i_vec(self%rank)

      integer :: p
      integer :: r
      integer :: j

      ! Calculate a vector index from a linear index

      p = self%n_lin
      r = i_lin - 1

      do j = self%rank, 1, -1
         p = p/self%shape(j)
         i_vec(j) = r/p + 1
         r = r - (i_vec(j)-1)*p
      end do

      @:ASSERT_DEBUG(i_lin == self%lin_from_vec(i_vec), 'indexing error')

      ! Finish

      return

   end function vec_from_lin

   !****

   function vec_from_stn_(self, i_cell, i_stn) result(i_vec)

      class(ngrid_t), intent(in) :: self
      integer, intent(in)        :: i_cell(:)
      integer, intent(in)        :: i_stn
      integer                    :: i_vec(self%rank)

      integer :: p
      integer :: r
      integer :: j

      @:CHECK_BOUNDS(SIZE(i_cell), self%rank)

      ! Calculate a vector index from cell and stencil indices

      p = self%n_stn
      r = i_stn - 1

      do j = self%rank, 1, -1
         p = p/4
         i_vec(j) = r/p + 1
         r = r - (i_vec(j)-1)*p
      end do

      i_vec = i_vec + i_cell - 2

      @:ASSERT_DEBUG(ALL(i_vec >= i_cell-1 .AND. i_vec <= i_cell+2), 'indexing error')

      ! Finish

      return

   end function vec_from_stn_

   !****

   subroutine interp_0_(self, data_proc, x_vec, f_int, stat, vderiv)

      class(ngrid_t), intent(in) :: self
      interface
         subroutine data_proc(i_vec, data, stat)
            use forum_m
            integer, intent(in)            :: i_vec(:)
            real(RD), intent(out)          :: data
            integer, intent(out), optional :: stat
         end subroutine data_proc
      end interface
      real(RD), intent(in)           :: x_vec(:)
      real(RD), intent(out)          :: f_int
      integer, intent(out), optional :: stat
      logical, intent(in), optional  :: vderiv(:)

      integer  :: i_cell(self%rank)
      logical  :: mask(self%n_stn)
      real(RD) :: vdelta(3,self%rank)
      real(RD) :: vu(self%rank)
      real(RD) :: K(self%n_stn,self%n_stn)
      integer  :: i_stn
      integer  :: i_vec(self%rank)
      real(RD) :: F(self%n_stn)
      real(RD) :: C(self%n_stn)

      @:CHECK_BOUNDS(SIZE(x_vec), self%rank)

      ! Interpolate a scalar value

      ! Set up the interpolation

      call self%setup_interp_(x_vec, i_cell, mask, vdelta, vu, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      ! Evaluate the kernel

      call eval_kernel(self%rank, mask, vdelta, K, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      ! Evaluate data at the stencil nodes

      do i_stn = 1, self%n_stn

         if (ANY(K(:,i_stn) /= 0._RD)) then

            i_vec = self%vec_from_stn_(i_cell, i_stn)

            call data_proc(i_vec, F(i_stn), stat)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            endif

         else

            F(i_stn) = 0._RD
            
         endif

      end do

      ! Evaluate the C vector

      C = MATMUL(K, F)

      ! Perform the interpolation

      call interp_ncubic(self%rank, vu, C, vdelta, f_int, vderiv)

      if (PRESENT(stat)) stat = STAT_OK

      ! Finish

      return

   end subroutine interp_0_

   !****

   subroutine interp_1_(self, data_proc, x_vec, f_int, stat, vderiv)

      class(ngrid_t), intent(in) :: self
      interface
         subroutine data_proc(i_vec, data, stat)
            use forum_m
            integer, intent(in)            :: i_vec(:)
            real(RD), intent(out)          :: data(:)
            integer, intent(out), optional :: stat
         end subroutine data_proc
      end interface
      real(RD), intent(in)           :: x_vec(:)
      real(RD), intent(out)          :: f_int(:)
      integer, intent(out), optional :: stat
      logical, intent(in), optional  :: vderiv(:)

      integer               :: i_cell(self%rank)
      logical               :: mask(self%n_stn)
      real(RD)              :: vdelta(3,self%rank)
      real(RD)              :: vu(self%rank)
      real(RD)              :: K(self%n_stn,self%n_stn)
      integer               :: n_m
      integer               :: i_stn
      integer               :: i_vec(self%rank)
      real(RD), allocatable :: F(:,:)
      real(RD)              :: C(self%n_stn)
      integer               :: m

      real(RD) :: x_1, x_2
      integer  :: r

      @:CHECK_BOUNDS(SIZE(x_vec), self%rank)

      ! Interpolate an array value

      ! Set up the interpolation

      call self%setup_interp_(x_vec, i_cell, mask, vdelta, vu, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      ! Evaluate the kernel

      call eval_kernel(self%rank, mask, vdelta, K, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      ! Evaluate data at the stencil nodes

      n_m = SIZE(f_int)

      allocate(F(self%n_stn,n_m))

      do i_stn = 1, self%n_stn

         if (ANY(K(:,i_stn) /= 0._RD)) then

            i_vec = self%vec_from_stn_(i_cell, i_stn)

            call data_proc(i_vec, F(i_stn,:), stat)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            endif

         else

            F(i_stn,:) = 0._RD

         endif

      end do

      ! Now loop through output points

      !$OMP PARALLEL DO PRIVATE(C)
      do m = 1, n_m

         ! Evaluate the C vector

         C = MATMUL(K, F(:,m))

         ! Perform the interpolation

         call interp_ncubic(self%rank, vu, C, vdelta, f_int(m), vderiv)

      end do

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine interp_1_

   !****
   
   subroutine setup_interp_(self, x_vec, i_cell, mask, vdelta, vu, stat)

      class(ngrid_t), intent(in)     :: self
      real(RD), intent(in)           :: x_vec(:)
      integer, intent(out)           :: i_cell(:)
      logical, intent(out)           :: mask(:)
      real(RD), intent(out)          :: vdelta(:,:)
      real(RD), intent(out)          :: vu(:)
      integer, intent(out), optional :: stat

      integer  :: j
      real(RD) :: x(4)
      logical  :: on_bdy(self%rank)
      integer  :: i_adj
      integer  :: i_cell_adj(self%rank)
      integer  :: i_cnr
      integer  :: i_vec(self%rank)
      integer  :: i_lin
      integer  :: i_stn
      integer  :: l
      integer  :: i

      @:CHECK_BOUNDS(SIZE(x_vec), self%rank)
      @:CHECK_BOUNDS(SIZE(i_cell), self%rank)
      @:CHECK_BOUNDS(SIZE(mask), self%n_stn)

      @:CHECK_BOUNDS(SIZE(vdelta, 1), 3)
      @:CHECK_BOUNDS(SIZE(vdelta, 2), self%rank)

      @:CHECK_BOUNDS(SIZE(vu), self%rank)

      ! Locate the starting interpolation cell

      call self%locate(x_vec, i_cell, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      i_cell = MIN(i_cell, self%shape-1)

      ! Determine whether the point lies on cell boundary(ies)

      do j = 1, self%rank
         call self%axes(j)%fetch(i_cell(j), x(j))
      end do

      on_bdy = x_vec == x

      ! Iterate over the interpolation cell and all adjacent cells

      adjacent_loop : do i_adj = 1, 2**self%rank

         do j = 1, self%rank

            ! Set up the cell index, weeding out cases that don't
            ! contain the point or don't exist

            if (BTEST(i_adj-1, j-1)) then

               if (.NOT. on_bdy(j)) cycle adjacent_loop
               if (i_cell(j) == 1) cycle adjacent_loop

               i_cell_adj(j) = i_cell(j) - 1

            else

               i_cell_adj(j) = i_cell(j)

            end if

         end do

         ! Check whether all corners are present

         corner_loop : do i_cnr = 1, 2**self%rank

            do j = 1, self%rank

               if (BTEST(i_cnr-1, j-1)) then
                  i_vec(j) = i_cell_adj(j) + 1
               else
                  i_vec(j) = i_cell_adj(j)
               endif

            end do

            i_lin = self%lin_from_vec(i_vec)

            if (.NOT. self%mask(i_lin)) cycle adjacent_loop

         end do corner_loop

         ! If so, set i_cell

         i_cell = i_cell_adj
         exit adjacent_loop

      end do adjacent_loop

      if (i_adj > 2**self%rank) then

         if (PRESENT(stat)) then
            stat = STAT_UNAVAILABLE_DATA
            return
         else
            @:ABORT('unavailable data')
         endif

      endif

      ! Set up the stencil mask

      do i_stn = 1, self%n_stn

         i_vec = self%vec_from_stn_(i_cell, i_stn)

         mask(i_stn) = .NOT. ANY(i_vec < 1 .OR. i_vec > self%shape)

         if (mask(i_stn)) then
            i_lin = self%lin_from_vec(i_vec)
            mask(i_stn) = mask(i_stn) .AND. self%mask(i_lin)
         end if

      end do

      ! Set up the vdelta and vu values

      do j = 1, self%rank

         do l = 1, 4

            i = i_cell(j) + l - 2

            if (i < 1) then
               x(l) = -HUGE(0._RD)
            elseif (i > self%shape(j)) then
               x(l) = HUGE(0._RD)
            else
               call self%axes(j)%fetch(i, x(l))
            endif

         end do

         vdelta(:,j) = x(2:4) - x(1:3)

         vu(j) = (x_vec(j) - x(2))/vdelta(2,j)

      end do

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine setup_interp_

   !****

   subroutine read(self, hdf5io, stat)

      class(ngrid_t), intent(out)    :: self
      type(hdf5io_t), intent(inout)  :: hdf5io
      integer, intent(out), optional :: stat

      character(TYPE_LEN)       :: type
      integer                   :: rank
      logical, allocatable      :: mask(:)
      type(axis_t), allocatable :: axes(:)
      integer                   :: j
      type(hdf5io_t)            :: hdf5io_axis

      ! Read the ngrid_t

      call hdf5io%read_attr('TYPE', type)
      if (type /= 'ngrid_t') then
         if (PRESENT(stat)) then
            stat = STAT_INVALID_TYPE
            return
         else
            @:ABORT('invalid type')
         endif
      endif

      call hdf5io%read_attr('rank', rank)

      allocate(axes(rank))

      axis_loop : do j = 1, rank
         hdf5io_axis = hdf5io_t(hdf5io, axis_group_name_(j))
         call axes(j)%read(hdf5io_axis, stat)
         call hdf5io_axis%final()
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif
      end do axis_loop

      call hdf5io%alloc_read_dset('mask', mask)

      select type(self)
      type is(ngrid_t)
         self = ngrid_t(axes, mask)
      class default
         @:ABORT('invalid type')
      end select

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine read

   !****

   subroutine write(self, hdf5io, stat)

      class(ngrid_t), intent(in)     :: self
      type(hdf5io_t), intent(inout)  :: hdf5io
      integer, intent(out), optional :: stat

      integer        :: j
      type(hdf5io_t) :: hdf5io_axis

      ! Write the ngrid
      
      call hdf5io%write_attr('TYPE', 'ngrid_t')

      call hdf5io%write_attr('shape', self%shape)
      call hdf5io%write_attr('rank', self%rank)

      axis_loop: do j = 1, self%rank
         hdf5io_axis = hdf5io_t(hdf5io, axis_group_name_(j))
         call self%axes(j)%write(hdf5io_axis, stat)
         call hdf5io_axis%final()
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif
      end do axis_loop

      call hdf5io%write_dset('mask', self%mask)

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine write

   !****

   function axis_group_name_(j) result (name)

      integer, intent(in) :: j
      character(256)      :: name

      write(name, 100) j
100   format('axes(',I0,')')

   end function axis_group_name_

end module ngrid_m
