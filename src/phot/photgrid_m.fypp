! Module  : photgrid_m
! Purpose : define photgrid_t type, for representing photometric intensity
!           grids
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module photgrid_m

   ! Uses
   
   use forum_m

   use ngrid_m
   use passband_m
   use photint_m
   use phottable_m
   use spec_phottable_m
   use spectable_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type :: photgrid_t
      private
      class(phottable_t), allocatable :: pt
      type(ngrid_t)                   :: ng
      integer, allocatable            :: shape(:)
      integer                         :: rank
   contains
      private
      procedure, public :: inquire
      #:for name in ('intensity', 'E_moment', 'D_moment', 'flux')
         procedure, public :: interp_${name}$
      #:endfor
   end type photgrid_t

   ! Interfaces

   interface photgrid_t
      module procedure photgrid_t_
   end interface photgrid_t

   interface read
      module procedure read_
      module procedure read_specgrid_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: photgrid_t
   public :: read
   public :: write

   ! Procedures
   
contains

   function photgrid_t_(pt, ng) result (pg)

      class(phottable_t), intent(in) :: pt
      type(ngrid_t), intent(in)      :: ng
      type(photgrid_t)               :: pg

      integer              :: n
      integer              :: n_ci
      integer              :: rank
      integer, allocatable :: shape(:)

      ! Construct the photgrid_t

      call pt%inquire(n=n)

      call ng%inquire(n_ci=n_ci, rank=rank)

      @:CHECK_BOUNDS(n, n_ci)

      allocate(shape(rank))

      call ng%inquire(shape=shape)

      pg%pt = pt
      pg%ng = ng

      pg%shape = shape
      pg%rank = rank

      ! Finish

      return

   end function photgrid_t_

   !****

   subroutine inquire(self, shape, rank, axis_min, axis_max, axis_labels)

      class(photgrid_t), intent(in)       :: self
      integer, intent(out), optional      :: shape(:)
      integer, intent(out), optional      :: rank
      real(RD), intent(out), optional     :: axis_min(:)
      real(RD), intent(out), optional     :: axis_max(:)
      character(*), intent(out), optional :: axis_labels(:)

      if (PRESENT(shape)) then
         @:CHECK_BOUNDS(SIZE(shape), self%rank)
      end if

      ! Inquire metadata

      if (PRESENT(shape)) shape = self%shape
      if (PRESENT(rank)) rank = self%rank

      call self%ng%inquire(axis_min=axis_min, axis_max=axis_max, axis_labels=axis_labels)

      ! Finish

      return

   end subroutine inquire

   !****

   #:for name, var, arg_var, arg_type in (('intensity', 'I', 'mu', 'real(RD)'), &
                                          ('E_moment', 'E', 'k', 'integer'), &
                                          ('D_moment', 'D', 'l', 'integer'))

      subroutine interp_${name}$(self, vx, ${arg_var}$, ${var}$, stat, vderiv)

         class(photgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: vx(:)
         ${arg_type}$, intent(in)         :: ${arg_var}$
         real(RD), intent(out)            :: ${var}$
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: vderiv(:)

         ! Interpolate the ${name}$

         call self%ng%interp(proc_, vx, ${var}$, stat, vderiv)

         ! Finish

      contains

         subroutine proc_(vi, f, stat)

            integer, intent(in)            :: vi(:)
            real(RD), intent(out)          :: f
            integer, intent(out), optional :: stat

            integer         :: li
            integer         :: ci
            type(photint_t) :: pi
            
            li = self%ng%li_from_vi(vi)
            ci = self%ng%ci_from_li(li)

            call self%pt%fetch(ci, pi, stat)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            end if

            call pi%interp_${name}$(${arg_var}$, f, stat)

            return

         end subroutine proc_

      end subroutine interp_${name}$

   #:endfor

   !****

   #:for name, var in (('flux', 'F'), )

      subroutine interp_${name}$(self, vx, ${var}$, stat, vderiv)

         class(photgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: vx(:)
         real(RD), intent(out)            :: ${var}$
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: vderiv(:)

         ! Interpolate the ${name}$

         call self%ng%interp(proc_, vx, ${var}$, stat, vderiv)

         ! Finish

      contains

         subroutine proc_(vi, f, stat)

            integer, intent(in)            :: vi(:)
            real(RD), intent(out)          :: f
            integer, intent(out), optional :: stat

            integer         :: li
            integer         :: ci
            type(photint_t) :: pi

            li = self%ng%li_from_vi(vi)
            ci = self%ng%ci_from_li(li)

            call self%pt%fetch(ci, pi, stat)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            end if

            call pi%interp_${name}$(f, stat)

            return

         end subroutine proc_

      end subroutine interp_${name}$

   #:endfor

   !****

   subroutine read_(hi, pg, stat)

      type(hdf5io_t), intent(inout)  :: hi
      type(photgrid_t), intent(out)  :: pg
      integer, intent(out), optional :: stat

      character(TYPE_LEN)             :: type
      type(hdf5io_t)                  :: hi_pt
      class(phottable_t), allocatable :: pt
      type(hdf5io_t)                  :: hi_ng
      type(ngrid_t)                   :: ng

      ! Read the photgrid_t

      call hi%read_attr('TYPE', type)
      if (type /= 'photgrid_t') then
         if (PRESENT(stat)) then
            stat = STAT_INVALID_TYPE
            return
         else
            @:ABORT('invalid type')
         endif
      endif

      hi_pt = hdf5io_t(hi, 'pt')
      call read(hi_pt, pt, stat)
      call hi_pt%final()
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      hi_ng = hdf5io_t(hi, 'ng')
      call read(hi_ng, ng, stat)
      call hi_ng%final()
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      pg = photgrid_t(pt, ng)

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine read_

   !****

   subroutine read_specgrid_(hi, pb, pg, stat)

      type(hdf5io_t), intent(inout)  :: hi
      type(passband_t), intent(in)   :: pb
      type(photgrid_t), intent(out)  :: pg
      integer, intent(out), optional :: stat

      character(TYPE_LEN)             :: type
      type(hdf5io_t)                  :: hi_st
      class(spectable_t), allocatable :: st
      type(hdf5io_t)                  :: hi_ng
      type(ngrid_t)                   :: ng

      ! Read the photgrid_t from the specgrid_t

      call hi%read_attr('TYPE', type)
      if (type /= 'specgrid_t') then
         if (PRESENT(stat)) then
            stat = STAT_INVALID_TYPE
            return
         else
            @:ABORT('invalid type')
         endif
      endif

      hi_st = hdf5io_t(hi, 'st')
      call read(hi_st, st, stat)
      call hi_st%final()
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      hi_ng = hdf5io_t(hi, 'ng')
      call read(hi_ng, ng, stat)
      call hi_ng%final()
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      pg = photgrid_t(spec_phottable_t(st, pb), ng)

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine read_specgrid_

   !****

   subroutine write_(hi, pg, stat)

      type(hdf5io_t), intent(inout)   :: hi
      type(photgrid_t), intent(inout) :: pg
      integer, intent(out), optional  :: stat

      type(hdf5io_t) :: hi_pt
      type(hdf5io_t) :: hi_ng

      ! Write the photgrid_t

      call hi%write_attr('TYPE', 'photgrid_t')

      call hi%write_attr('shape', pg%shape)
      call hi%write_attr('rank', pg%rank)

      hi_pt = hdf5io_t(hi, 'pt')
      call write(hi_pt, pg%pt, stat)
      call hi_pt%final()
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if
      
      hi_ng = hdf5io_t(hi, 'ng')
      call write(hi_ng, pg%ng, stat)
      call hi_ng%final()
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine write_

end module photgrid_m
