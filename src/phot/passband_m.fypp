! Module  : passband_m
! Purpose : define passband_t type, representing a photometric passband
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module passband_m

   ! Uses

   use forum_m

   use cubint_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type passband_t
      private
      type(cubint_t) :: ci
      real(RD)       :: D
      real(RD)       :: ZP
      real(RD)       :: lam_min
      real(RD)       :: lam_max
   contains
      private
      procedure, public :: get_support
      procedure, public :: passthru
   end type passband_t

   ! Interfaces

   interface passband_t
      module procedure passband_t_
      module procedure passband_t_cubint_
   end interface passband_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: passband_t
   public :: read
   public :: write

   ! Procedures

contains

   function passband_t_(S, lam, ZP) result(pb)

      real(RD), intent(in) :: S(:)
      real(RD), intent(in) :: lam(:)
      real(RD), intent(in) :: ZP
      type(passband_t)     :: pb

      real(RD)       :: lam_min
      real(RD)       :: lam_max
      type(cubint_t) :: ci
      real(RD)       :: D

      @:CHECK_BOUNDS(SIZE(lam), SIZE(S))

      ! Construct the passband_t from the supplied data

      lam_min = lam(1)
      lam_max = lam(SIZE(lam))

      ci = cubint_t(lam, C_LIGHT*S/lam, 'SPLINE')
      D = ci%integ(lam_max) - ci%integ(lam_min)

      pb = passband_t(cubint_t(lam, S, 'SPLINE'), D, ZP)

      ! Finish

      return

   end function passband_t_

   !****

   function passband_t_cubint_(ci, D, ZP) result(pb)

      type(cubint_t), intent(in) :: ci
      real(RD), intent(in)       :: D
      real(RD), intent(in)       :: ZP
      type(passband_t)           :: pb

      real(RD) :: lam_min
      real(RD) :: lam_max

      ! Construct the passband_t from the supplied data

      call ci%get_domain(lam_min, lam_max)

      pb%ci = ci

      pb%D = D
      pb%ZP = ZP

      pb%lam_min = lam_min
      pb%lam_max = lam_max

      ! Finish

      return

   end function passband_t_cubint_

   !****

   subroutine get_support(self, lam_min, lam_max)

      class(passband_t), intent(in) :: self
      real(RD), intent(out)         :: lam_min
      real(RD), intent(out)         :: lam_max

      ! Get the support (non-zero interval) of the passband response

      lam_min = self%lam_min
      lam_max = self%lam_max

      ! Finish

      return

   end subroutine get_support

   !****

   function passthru(self, lam_a, lam_b) result (P)

      class(passband_t), intent(in) :: self
      real(RD), intent(in)          :: lam_a
      real(RD), intent(in)          :: lam_b
      real(RD)                      :: P

      real(RD) :: lam_a_
      real(RD) :: lam_b_

      ! Evaluate the passthru P = int_a^b S(lam) dlam

      lam_a_ = MIN(MAX(lam_a, self%lam_min), self%lam_max)
      lam_b_ = MIN(MAX(lam_b, self%lam_min), self%lam_max)

      P = self%ci%integ(lam_b_) - self%ci%integ(lam_a_)

      ! Finish

      return

   end function passthru

   !****

   subroutine read_(hi, pb, stat)

      type(hdf5io_t), intent(inout)  :: hi
      type(passband_t), intent(out)  :: pb
      integer, intent(out), optional :: stat

      character(TYPE_LEN) :: type
      real(RD)            :: D
      real(RD)            :: ZP
      type(hdf5io_t)      :: hi_ci
      type(cubint_t)      :: ci

      ! Read the passband_t

      call hi%read_attr('TYPE', type)
      if (type /= 'passband_t') then
         if (PRESENT(stat)) then
            stat = STAT_INVALID_TYPE
         else
            @:ABORT('invalid type')
         endif
      endif

      call hi%read_attr('D', D)
      call hi%read_attr('ZP', ZP)

      hi_ci = hdf5io_t(hi, 'ci')
      call read(hi_ci, ci)
      call hi_ci%final()

      pb = passband_t(ci, D, ZP)

      ! Finish

   end subroutine read_

   !****

   subroutine write_(hi, pb)

      type(hdf5io_t), intent(inout) :: hi
      type(passband_t), intent(in)  :: pb

      type(hdf5io_t) :: hi_ci

      ! Write the passband_t

      call hi%write_attr('TYPE', 'passband_t')

      call hi%write_attr('D', pb%D)
      call hi%write_attr('ZP', pb%ZP)

      hi_ci = hdf5io_t(hi, 'ci')
      call write(hi_ci, pb%ci)
      call hi_ci%final()

      ! Finish

   end subroutine write_
   
end module passband_m
