! Module  : passband_m
! Purpose : define passband_t type, representing a photometric passband
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module passband_m

   ! Uses

   use forum_m

   use cubint_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type passband_t
      private
      type(cubint_t) :: ci
      real(RD)       :: F_0
      real(RD)       :: Delta
      real(RD)       :: lam_min
      real(RD)       :: lam_max
   contains
      private
      procedure, public :: inquire
      procedure, public :: passthru
   end type passband_t

   ! Interfaces

   interface passband_t
      module procedure passband_t_
   end interface passband_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: passband_t
   public :: read
   public :: write

   ! Procedures

contains

   function passband_t_(S, lam, F_0) result(pb)

      real(RD), intent(in) :: S(:)
      real(RD), intent(in) :: lam(:)
      real(RD), intent(in) :: F_0
      type(passband_t)     :: pb

      @:CHECK_BOUNDS(SIZE(lam), SIZE(S))

      ! Construct the passband_t from the supplied data

      pb = passband_t_cubint_(cubint_t(lam, S, 'SPLINE'), F_0)

      ! Finish

      return

   end function passband_t_

   !****

   function passband_t_cubint_(ci, F_0) result(pb)

      type(cubint_t), intent(in) :: ci
      real(RD), intent(in)       :: F_0
      type(passband_t)           :: pb

      ! Construct the passband_t from the cubint_t

      pb%ci = ci

      call ci%inquire(x_min=pb%lam_min, x_max=pb%lam_max)

      pb%F_0 = F_0
      pb%Delta = ci%integ(pb%lam_max) - ci%integ(pb%lam_min)

      ! Finish

      return

   end function passband_t_cubint_

   !****

   subroutine inquire(self, lam_min, lam_max)

      class(passband_t), intent(in)   :: self
      real(RD), intent(out), optional :: lam_min
      real(RD), intent(out), optional :: lam_max

      ! Inquire metadata

      if (PRESENT(lam_min)) lam_min = self%lam_min
      if (PRESENT(lam_max)) lam_min = self%lam_max

      ! Finish

      return

   end subroutine inquire

   !****

   function passthru(self, lam_a, lam_b) result (P)

      class(passband_t), intent(in) :: self
      real(RD), intent(in)          :: lam_a
      real(RD), intent(in)          :: lam_b
      real(RD)                      :: P

      real(RD) :: lam_a_
      real(RD) :: lam_b_

      ! Evaluate the passthru P = int_a^b S(lam) dlam / D

      lam_a_ = MIN(MAX(lam_a, self%lam_min), self%lam_max)
      lam_b_ = MIN(MAX(lam_b, self%lam_min), self%lam_max)

      P = (self%ci%integ(lam_b_) - self%ci%integ(lam_a_))/(self%F_0*self%Delta)

      ! Finish

      return

   end function passthru

   !****

   subroutine read_(hi, pb, stat)

      type(hdf5io_t), intent(inout)  :: hi
      type(passband_t), intent(out)  :: pb
      integer, intent(out), optional :: stat

      character(TYPE_LEN) :: type
      real(RD)            :: F_0
      type(hdf5io_t)      :: hi_ci
      type(cubint_t)      :: ci

      ! Read the passband_t

      call hi%read_attr('TYPE', type)
      if (type /= 'passband_t') then
         if (PRESENT(stat)) then
            stat = STAT_INVALID_TYPE
         else
            @:ABORT('invalid type')
         endif
      endif

      call hi%read_attr('F_0', F_0)

      hi_ci = hdf5io_t(hi, 'ci')
      call read(hi_ci, ci)
      call hi_ci%final()

      pb = passband_t_cubint_(ci, F_0)

      ! Finish

      return

   end subroutine read_

   !****

   subroutine write_(hi, pb)

      type(hdf5io_t), intent(inout) :: hi
      type(passband_t), intent(in)  :: pb

      type(hdf5io_t) :: hi_ci

      ! Write the passband_t

      call hi%write_attr('TYPE', 'passband_t')

      call hi%write_attr('F_0', pb%F_0)

      hi_ci = hdf5io_t(hi, 'ci')
      call write(hi_ci, pb%ci)
      call hi_ci%final()

      ! Finish

      return

   end subroutine write_
   
end module passband_m
