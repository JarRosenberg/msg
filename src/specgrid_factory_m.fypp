! Module   : specgrid_factory_m
! Purpose  : factory procedures for specgrid_t type
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module specgrid_factory_m

  ! Uses
  
   use kinds_m
   
   use specint_m
   use specnode_m
   use specgrid_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Access specifiers

   private

   public :: specgrid_from_grid

   ! Procedures

contains

   function specgrid_from_grid(si, mask, lnT, lng) result (rg)

      type(specint_t), intent(in) :: si(:,:)
      logical, intent(in)         :: mask(:,:)
      real(RD), intent(in)        :: lnT(:)
      real(RD), intent(in)        :: lng(:)
      type(specgrid_t)            :: rg

      integer                       :: n_lnT
      integer                       :: n_lng
      real(RD), allocatable         :: lnT_g(:)
      real(RD), allocatable         :: lng_g(:)
      type(specint_t), allocatable  :: si_g(:,:)
      logical, allocatable          :: mask_g(:,:)
      type(specnode_t), allocatable :: sn(:,:)
      logical, allocatable          :: mask_sn(:,:)
      integer                       :: i
      integer                       :: j
      
      @:CHECK_BOUNDS(SIZE(mask, 1), SIZE(si, 1))
      @:CHECK_BOUNDS(SIZE(mask, 2), SIZE(si, 2))

      @:CHECK_BOUNDS(SIZE(lnT), SIZE(si, 1))
      @:CHECK_BOUNDS(SIZE(lng), SIZE(si, 2))

      ! Construct the specgrid_t from the grid of specint_t's

      ! Add ghost zones to the grid

      n_lnT = SIZE(lnT)
      n_lng = SIZE(lng)

      allocate(lnT_g(0:n_lnT+1))
      allocate(lng_g(0:n_lng+1))

      lnT_g(1:n_lnT) = lnT
      lng_g(1:n_lng) = lng

      allocate(si_g(0:n_lnT+1,0:n_lng+1))
      allocate(mask_g(0:n_lnT+1,0:n_lng+1))

      si_g(1:n_lnT,1:n_lng) = si

      mask_g(1:n_lnT,1:n_lng) = mask
      mask_g(0,:) = .FALSE.
      mask_g(n_lnT+1,:) = .FALSE.
      mask_g(:,0) = .FALSE.
      mask_g(:,n_lng+1) = .FALSE.

      ! Allocate space for the specnode_t's and their mask

      allocate(sn(n_lnT,n_lng))
      allocate(mask_sn(n_lnT,n_lng))

      mask_sn = .FALSE.

      ! For each masked-in node in the grid, set up the specnode_t

      lnT_loop : do i = 1, n_lnT
         lng_loop : do j = 1, n_lng

            if (mask(i,j)) then

               ! Evaluate derivatives

               eval_block : block

                  logical        :: deriv_ok
                  type(specint_t) :: dsi_dlnT
                  type(specint_t) :: dsi_dlng
                  type(specint_t) :: d2si_dlnTdlng
                  
                  call eval_first_deriv_(si_g(i-1:i+1,j), mask_g(i-1:i+1,j), lnT_g(i-1:i+1), dsi_dlnT, deriv_ok)
                  if (.NOT. deriv_ok) exit eval_block

                  call eval_first_deriv_(si_g(i,j-1:j+1), mask_g(i,j-1:j+1), lng_g(j-1:j+1), dsi_dlng, deriv_ok)
                  if (.NOT. deriv_ok) exit eval_block

                  call eval_cross_deriv_(si_g(i-1:i+1,j-1:j+1), mask_g(i-1:i+1,j-1:j+1), &
                       lnT_g(i-1:i+1), lng_g(j-1:j+1), d2si_dlnTdlng, deriv_ok)
                  if (.NOT. deriv_ok) exit eval_block

                  ! Set up the specnode

                  sn(i,j) = specnode_t(si(i,j), dsi_dlnT, dsi_dlng, d2si_dlnTdlng)
                  mask_sn(i,j) = .TRUE.

                end block eval_block

            end if

         end do lng_loop
      end do lnT_loop

      ! Print out grid architecture

      print 100, NINT(exp(lnT(1))), REPEAT(' ', n_lnT-9), NINT(exp(lnT(n_lnT)))
100   format(5X,I4,A,I5)

      do j = n_lng, 1, -1
         print 110, lng(j)/log(10._RD), MERGE('X', '.', mask_sn(:,j))
110      format(F4.2,1X,9999A1)
      end do

      ! Construct the specgrid_t

      rg = specgrid_t(sn, mask_sn, lnT, lng)

      ! Finish

      return

   end function specgrid_from_grid

   !****

   subroutine eval_first_deriv_ (si, mask, x, dsi_dx, deriv_ok)

      type(specint_t), intent(in)  :: si(:)
      logical, intent(in)          :: mask(:)
      real(RD), intent(in)         :: x(:)
      type(specint_t), intent(out) :: dsi_dx
      logical, intent(out)         :: deriv_ok

      logical        :: mask_fd(2)
      type(specint_t) :: dsi_fd(2)
      real(RD)       :: u

      ! Evaluate the first derivative

      ! Set up finite differences

      if (mask(1)) then
         mask_fd(1) = .TRUE.
         dsi_fd(1) = (si(2) - si(1))/(x(2) - x(1))
      else
         mask_fd(1) = .FALSE.
      endif

      if (mask(3)) then
         mask_fd(2) = .TRUE.
         dsi_fd(2) = (si(3) - si(2))/(x(3) - x(2))
      else
         mask_fd(2) = .FALSE.
      endif

      ! Blend them to create the first derivative

      select case (COUNT(mask_fd))
      case (0)
         deriv_ok = .FALSE.
      case (1)
         if (mask_fd(1)) then
            dsi_dx = dsi_fd(1)
         else
            dsi_dx = dsi_fd(2)
         endif
         deriv_ok = .TRUE.
      case (2)
         u = (x(2) - x(1))/(x(3) - x(1))
         dsi_dx = (1._RD-u)*dsi_fd(1) + u*dsi_fd(2)
         deriv_ok = .TRUE.
      end select

      ! Finish

      return

   end subroutine eval_first_deriv_

   !****

   subroutine eval_cross_deriv_ (si, mask, x, y, d2si_dxdy, deriv_ok)

      type(specint_t), intent(in)  :: si(:,:)
      logical, intent(in)          :: mask(:,:)
      real(RD), intent(in)         :: x(:)
      real(RD), intent(in)         :: y(:)
      type(specint_t), intent(out) :: d2si_dxdy
      logical, intent(out)         :: deriv_ok

      logical         :: mask_fd(4)
      type(specint_t) :: d2si_fd(4)
      real(RD)        :: u
      real(RD)        :: v

      ! Evaluate the cross derivative

      ! Set up finite differences

      if (ALL(mask(1:2,1:2))) then
         mask_fd(1) = .TRUE.
         d2si_fd(1) = (si(1,1) + si(2,2) - si(2,1) - si(1,2))/((x(2) - x(1))*(y(2) - y(1)))
      else
         mask_fd(1) = .FALSE.
      endif

      if (ALL(mask(2:3,1:2))) then
         mask_fd(2) = .TRUE.
         d2si_fd(2) = (si(2,1) + si(3,2) - si(3,1) - si(2,2))/((x(3) - x(2))*(y(2) - y(1)))
      else
         mask_fd(2) = .FALSE.
      endif

      if (ALL(mask(1:2,2:3))) then
         mask_fd(3) = .TRUE.
         d2si_fd(3) = (si(1,2) + si(2,3) - si(2,2) - si(1,3))/((x(2) - x(1))*(y(3) - y(2)))
      else
         mask_fd(3) = .FALSE.
      endif

      if (ALL(mask(2:3,2:3))) then
         mask_fd(4) = .TRUE.
         d2si_fd(4) = (si(2,2) + si(3,3) - si(3,2) - si(2,3))/((x(3) - x(2))*(y(3) - y(2)))
      else
         mask_fd(4) = .FALSE.
      endif

      ! Blend them to create the first derivative

      select case (COUNT(mask_fd))
      case (0)
         deriv_ok = .FALSE.
      case (1)
         if (mask_fd(1)) then
            d2si_dxdy = d2si_fd(1)
         elseif (mask_fd(2)) then
            d2si_dxdy = d2si_fd(2)
         elseif (mask_fd(3)) then
            d2si_dxdy = d2si_fd(3)
         else
            d2si_dxdy = d2si_fd(4)
         endif
         deriv_ok = .TRUE.
      case (2)
         if (mask_fd(1) .AND. mask_fd(2)) then
            u = (x(2) - x(1))/(x(3) - x(1))
            d2si_dxdy = (1._RD-u)*d2si_fd(1) + u*d2si_fd(2)
            deriv_ok = .TRUE.
         elseif (mask_fd(3) .AND. mask_fd(4)) then
            u = (x(2) - x(1))/(x(3) - x(1))
            d2si_dxdy = (1._RD-u)*d2si_fd(3) + u*d2si_fd(4) 
            deriv_ok = .TRUE.
         elseif (mask_fd(1) .AND. mask_fd(3)) then
            v = (y(2) - y(1))/(y(3) - y(1))
            d2si_dxdy = (1._RD-v)*d2si_fd(1) + v*d2si_fd(3)
            deriv_ok = .TRUE.
         elseif (mask_fd(2) .AND. mask_fd(4)) then
            v = (y(2) - y(1))/(y(3) - y(1))
            d2si_dxdy = (1._RD-v)*d2si_fd(2) + v*d2si_fd(4)
            deriv_ok = .TRUE.
         else
            deriv_ok =.FALSE.
         end if
      case (3)
         if (.NOT. mask_fd(1)) then
            d2si_dxdy = d2si_fd(4)
         elseif (.NOT. mask_fd(2)) then
            d2si_dxdy = d2si_fd(3)
         elseif (.NOT. mask_fd(3)) then
            d2si_dxdy = d2si_fd(2)
         else
            d2si_dxdy = d2si_fd(1)
         endif
         deriv_ok = .TRUE.
      case (4)
         u = (x(2) - x(1))/(x(3) - x(1))
         v = (y(2) - y(1))/(y(3) - y(1))
         d2si_dxdy = &
              (1._RD-u)*(1._RD-v)*d2si_fd(1) + &
              (      u)*(1._RD-v)*d2si_fd(2) + &
              (1._RD-u)*(      v)*d2si_fd(3) + &
              (      u)*(      v)*d2si_fd(4)
         deriv_ok = .TRUE.
      end select

      ! Finish

      return

    end subroutine eval_cross_deriv_

end module specgrid_factory_m
         
         
         

      

      
