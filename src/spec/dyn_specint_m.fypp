! Module  : dyn_specint_m
! Purpose : define dyn_specint_t type, for adding dynamic loading to the
!           specint_t type
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module dyn_specint_m

   ! Uses

   use forum_m

   use specint_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type, extends(specint_t) :: dyn_specint_t
      private
      character(:), allocatable :: file_name
      character(:), allocatable :: group_name
      real(RD)                  :: lam_min
      real(RD)                  :: lam_max
      logical                   :: loaded = .FALSE.
      logical                   :: sticky = .TRUE.
   contains
      private
      procedure, public :: inquire
      #:for name in ('intensity', 'D_moment', 'flux')
         procedure, public :: interp_${name}$
      #:endfor
      procedure, public :: flush
      procedure         :: load_
   end type dyn_specint_t

   ! Interfaces

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: dyn_specint_t
   public :: read
   public :: write

   ! Procedures

contains

   subroutine inquire(self, lam_min, lam_max, low_acc)

      class(dyn_specint_t), intent(in) :: self
      real(RD), intent(out), optional  :: lam_min
      real(RD), intent(out), optional  :: lam_max
      logical, intent(out), optional   :: low_acc

      ! Inquire metadata

      if (self%loaded) then

         call self%specint_t%inquire(lam_min, lam_max, low_acc)

      else

         if (PRESENT(lam_min)) lam_min = self%lam_min
         if (PRESENT(lam_max)) lam_max = self%lam_max

         ! Do not handle low_acc

      endif

      ! Finish

      return

   end subroutine inquire

   !****

   #:for name, var, arg_var, arg_type in (('intensity', 'I', 'mu', 'real(RD)'), &
                                         ('D_moment', 'D', 'l', 'integer'))

      subroutine interp_${name}$(self, ${arg_var}$, lam, ${var}$, stat)

         class(dyn_specint_t), intent(inout) :: self
         ${arg_type}$, intent(in)            :: ${arg_var}$
         real(RD), intent(in)                :: lam(:)
         real(RD), intent(out)               :: ${var}$(:)
         integer, intent(out), optional      :: stat

         ! If necessary, load

         if (.NOT. self%loaded) then

            call self%load_(stat)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            endif

         endif
         
         ! Pass

         call self%specint_t%interp_${name}$(${arg_var}$, lam, ${var}$, stat)

         ! If necesarry, flush

         if (.NOT. self%sticky) call self%flush()

         ! Finish

         return

      end subroutine interp_${name}$

   #:endfor
      
   !****

   #:for name, var in (('flux', 'F'),)

      subroutine interp_${name}$(self, lam, ${var}$, stat)

         class(dyn_specint_t), intent(inout) :: self
         real(RD), intent(in)                :: lam(:)
         real(RD), intent(out)               :: ${var}$(:)
         integer, intent(out), optional      :: stat

         ! If necessary, load

         if (.NOT. self%loaded) then

            call self%load_(stat)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            endif

         endif
         
         ! Pass

         call self%specint_t%interp_${name}$(lam, ${var}$, stat)

         ! If necesarry, flush

         if (.NOT. self%sticky) call self%flush()

         ! Finish

         return

      end subroutine interp_${name}$

   #:endfor

   !****

   subroutine flush(self)

      class(dyn_specint_t), intent(out) :: self

      ! Flush the dyn_specint_t

      call flush_si_(self%specint_t)

      self%loaded = .FALSE.

      ! Finish

      return

   contains

      subroutine flush_si_(si)

         type(specint_t), intent(out) :: si

      end subroutine flush_si_

   end subroutine flush

   !****

   subroutine load_(self, stat)
      
      class(dyn_specint_t), intent(inout) :: self
      integer, intent(out), optional      :: stat

      type(hdf5io_t) :: hi
      type(hdf5io_t) :: hi_si
      real(RD)       :: lam_min
      real(RD)       :: lam_max

      ! Load data for the specint_t

      hi = hdf5io_t(self%file_name, OPEN_FILE_RO)
      hi_si = hdf5io_t(hi, self%group_name)

      call read(hi_si, self%specint_t)

      call hi_si%final()
      call hi%final()

      self%loaded = .TRUE.

      ! Consistency check

      call self%inquire(lam_min, lam_max)

      @:ASSERT(lam_min == self%lam_min, 'inconsistent lam_min')
      @:ASSERT(lam_max == self%lam_max, 'inconsistent lam_max')

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine load_

   !****

   subroutine read_(hi, si, stat, sticky)

      type(hdf5io_t), intent(inout)    :: hi
      type(dyn_specint_t), intent(out) :: si
      integer, intent(out), optional   :: stat
      logical, intent(in), optional    :: sticky

      logical             :: sticky_
      character(TYPE_LEN) :: type

      ! Read the dyn_specint_t (the specint_t supertype is set in a
      ! later call to load_)

      call hi%read_attr('TYPE', type)
      if (type /= 'specint_t') then
         if (PRESENT(stat)) then
            stat = STAT_INVALID_TYPE
            return
         else
            @:ABORT('invalid type')
         endif
      endif

      call hi%read_attr('lam_min', si%lam_min)
      call hi%read_attr('lam_max', si%lam_max)

      call hi%inquire(file_name=si%file_name, group_name=si%group_name)

      if (PRESENT(sticky)) si%sticky = sticky

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine read_

   !****

   subroutine write_(hi, si)

      type(hdf5io_t), intent(inout)      :: hi
      type(dyn_specint_t), intent(inout) :: si

      ! Write the dyn_specint_t

      if (.NOT. si%loaded) call si%load_()

      call write(hi, si%specint_t)

      if (.NOT. si%sticky) call si%flush()

      ! Finish

      return

   end subroutine write_
   
end module dyn_specint_m
