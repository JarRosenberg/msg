! Module  : specint_m
! Purpose : define specint_t type, for representing spectral intensity
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module specint_m

   ! Uses

   use forum_m

   use limb_m
   use math_m
   use passband_m
   use photint_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type specint_t
      private
      real(RD), allocatable :: c(:,:)
      real(RD), allocatable :: lam(:)
      type(limb_t)          :: li
      integer               :: n
      integer               :: m
   contains
      private
      procedure, public :: inquire
      #:for name in ('intensity', 'E_moment', 'D_moment', 'flux')
         procedure, public :: interp_${name}$
      #:endfor
      procedure         :: interp_f_
      procedure, public :: apply_passband
   end type specint_t

   ! Interfaces

   interface specint_t
      module procedure specint_t_
      module procedure specint_t_fit_
      module procedure specint_t_interp_
      module procedure specint_t_subset_
   end interface specint_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: specint_t
   public :: read
   public :: write

   ! Procedures

contains

   function specint_t_(c, lam, li) result (si)

      real(RD), intent(in)     :: c(:,:)
      real(RD), intent(in)     :: lam(:)
      type(limb_t), intent(in) :: li
      type(specint_t)          :: si

      integer :: n
      integer :: m

      ! Construct the specint_t from the supplied data

      n = SIZE(c, 1)
      m = SIZE(c, 2)

      @:CHECK_BOUNDS(n, li%n_basis())
      @:CHECK_BOUNDS(m, SIZE(lam)-1)

      @:ASSERT_DEBUG(ALL(lam(2:) > lam(:m)),'Non-monotonic wavelength data')

      si%c = c
      si%lam = lam
      si%li = li

      si%n = n
      si%m = m
      
      ! Finish

      return

   end function specint_t_

   !****

   function specint_t_fit_(I, mu, lam, li) result (si)

      real(RD), intent(in)     :: I(:,:)
      real(RD), intent(in)     :: mu(:)
      real(RD), intent(in)     :: lam(:)
      type(limb_t), intent(in) :: li
      type(specint_t)          :: si

      real(RD), allocatable :: c(:,:)

      ! Construct the specint_t by fitting the supplied I(mu,lambda)
      ! intensity data

      call li%fit_intensity(I, mu, c)

      si = specint_t(c, lam, li)

      ! Finish

      return

   end function specint_t_fit_

   !****

   function specint_t_interp_(si_in, lam) result (si)

      type(specint_t), intent(inout) :: si_in
      real(RD), intent(in)           :: lam(:)
      type(specint_t)                :: si

      integer               :: m
      real(RD), allocatable :: c(:,:)
      integer               :: p
      real(RD)              :: b(si_in%n)

      ! Construct the specint_t by interpolating the supplied
      ! specint_t onto the lam abscissa

      m = SIZE(lam) - 1

      allocate(c(si_in%n,m))

      do p = 1, si_in%n

         b = 0._RD
         b(p) = 1._RD

         call si_in%interp_f_(b, lam, c(p,:))

      end do

      si = specint_t(c, lam, si_in%li)

      ! Finish

      return

   end function specint_t_interp_

   !****

   function specint_t_subset_(si_in, lam_min, lam_max) result (si)

      type(specint_t), intent(in) :: si_in
      real(RD), intent(in)        :: lam_min
      real(RD), intent(in)        :: lam_max
      type(specint_t)             :: si

      integer :: i_a
      integer :: i_b

      ! Construct the specint_t by subsetting the supplied specint_t

      i_a = FINDLOC(si_in%lam >= lam_min, .TRUE., DIM=1)
      i_b = FINDLOC(si_in%lam <= lam_max, .TRUE., DIM=1,BACK=.TRUE.)

      i_a = MAX(i_a, 1)
      i_b = MIN(i_b, si_in%m)

      si = specint_t(si_in%c(:,i_a:i_b), si_in%lam(i_a:i_b+1), si_in%li)

      ! Finish

      return

   end function specint_t_subset_

   !****

   subroutine inquire(self, lam_min, lam_max)

      class(specint_t), intent(in)    :: self
      real(RD), intent(out), optional :: lam_min
      real(RD), intent(out), optional :: lam_max

      ! Inquire metadata

      if (PRESENT(lam_min)) lam_min = self%lam(1)
      if (PRESENT(lam_max)) lam_max = self%lam(self%m)

      ! Finish

      return

   end subroutine inquire

   !****

   #:for name, var, arg_var, arg_type in (('intensity', 'I', 'mu', 'real(RD)'), &
                                          ('E_moment', 'E', 'k', 'integer'), &
                                          ('D_moment', 'D', 'l', 'integer'))

      subroutine interp_${name}$(self, ${arg_var}$, lam, ${var}$, stat)

         class(specint_t), intent(inout) :: self
         ${arg_type}$, intent(in)        :: ${arg_var}$
         real(RD), intent(in)            :: lam(:)
         real(RD), intent(out)           :: ${var}$(:)
         integer, intent(out), optional  :: stat

         real(RD) :: b(self%n)

         ! Set up the basis functions

         call self%li%eval_${name}$_basis(${arg_var}$, b, stat)
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif

         ! Do the interpolation

         call self%interp_f_(b, lam, ${var}$, stat)

         ! Finish

         return

      end subroutine interp_${name}$

   #:endfor
      
   !****

   #:for name, var in (('flux', 'F'),)

      subroutine interp_${name}$(self, lam, ${var}$, stat)

         class(specint_t), intent(inout) :: self
         real(RD), intent(in)            :: lam(:)
         real(RD), intent(out)           :: ${var}$(:)
         integer, intent(out), optional  :: stat

         real(RD) :: b(self%n)

         ! Set up the basis functions

         call self%li%eval_${name}$_basis(b, stat)
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif

         ! Do the interpolation

         call self%interp_f_(b, lam, ${var}$, stat)

         ! Finish

         return

      end subroutine interp_${name}$

   #:endfor

   !****
      
   subroutine interp_f_(self, b, lam, f, stat)

      class(specint_t), intent(inout) :: self
      real(RD), intent(in)            :: b(:)
      real(RD), intent(in)            :: lam(:)
      real(RD), intent(out)           :: f(:)
      integer, intent(out), optional  :: stat

      integer  :: i
      integer  :: j
      integer  :: m
      real(RD) :: lam_a
      real(RD) :: lam_b

      @:CHECK_BOUNDS(SIZE(b), self%n)
      @:CHECK_BOUNDS(SIZE(f), SIZE(lam)-1)

      ! Set up indices
         
      call locate(self%lam, lam(1), i)

      if (i < 1) then
         if (PRESENT(stat)) then
            stat = STAT_OUT_OF_BOUNDS_LAM_LO
            return
         else
            @:ABORT('out-of-bounds (lo) lam')
         endif
      endif

      if (i >= self%m) then
         if (PRESENT(stat)) then
            stat = STAT_OUT_OF_BOUNDS_LAM_HI
            return
         else
            @:ABORT('out-of-bounds (hi) lam')
         endif
      endif

      j = 1
      m = SIZE(f)

      ! Perform the interpolation (conservative piecewise-constant
      ! rebin)

      f = 0._RD

      interp_loop : do

         if (j > m) exit interp_loop

         lam_a = MAX(self%lam(i), lam(j))
         lam_b = MIN(self%lam(i+1), lam(j+1))

         f(j) = f(j) + (lam_b - lam_a)/(lam(j+1) - lam(j))*DOT_PRODUCT(b, self%c(:,i))

         if (lam_b == self%lam(i+1)) i = i + 1
         if (lam_b == lam(j+1)) j = j + 1

      end do interp_loop

      if (PRESENT(stat)) stat = STAT_OK

      ! Finish

      return

   end subroutine interp_f_

   !****

   subroutine apply_passband(self, pb, pi, stat)

      class(specint_t), intent(in)   :: self
      type(passband_t), intent(in)   :: pb
      type(photint_t), intent(out)   :: pi
      integer, intent(out), optional :: stat

      real(RD) :: lam_min
      real(RD) :: lam_max
      real(RD) :: lam_min_pb
      real(RD) :: lam_max_pb
      real(RD) :: c(self%n)
      integer  :: i
      real(RD) :: P

      ! Apply the passband, to yield a photint_t

      ! First check that the spectrum is defined across the passband support

      call self%inquire(lam_min=lam_min, lam_max=lam_max)
      call pb%inquire(lam_min=lam_min_pb, lam_max=lam_max_pb)

      if (lam_min_pb < lam_min) then
         if (PRESENT(stat)) then
            stat = STAT_OUT_OF_BOUNDS_LAM_LO
            return
         else
            @:ABORT('out-of-bounds (lo) lam')
         endif
      endif

      if (lam_max_pb > lam_max) then
         if (PRESENT(stat)) then
            stat = STAT_OUT_OF_BOUNDS_LAM_HI
            return
         else
            @:ABORT('out-of-bounds (hi) lam')
         endif
      endif

      ! Evaluate the coefficients

      c = 0._RD

      coeff_loop : do i = 1, self%m

         ! Evaluate the passthrough

         P = pb%passthru(self%lam(i), self%lam(i+1))

         ! Add the contribution to c

         c = c + P*self%c(:,i)

      end do coeff_loop

      ! Construct the photint

      pi = photint_t(c, self%li)

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine apply_passband

   !****

   subroutine read_(hi, si, stat)

      type(hdf5io_t), intent(inout)  :: hi
      type(specint_t), intent(out)   :: si
      integer, intent(out), optional :: stat

      character(TYPE_LEN)   :: type
      real(RD), allocatable :: lam(:)
      real(RD), allocatable :: c(:,:)
      type(hdf5io_t)        :: hi_li
      type(limb_t)          :: li

      ! Read the specint_t

      call hi%read_attr('TYPE', type)
      if (type /= 'specint_t') then
         if (PRESENT(stat)) then
            stat = STAT_INVALID_TYPE
            return
         else
            @:ABORT('invalid type')
         endif
      endif

      call hi%alloc_read_dset('lam', lam)
      call hi%alloc_read_dset('c', c)

      hi_li = hdf5io_t(hi, 'li')
      call read(hi_li, li)
      call hi_li%final()

      si = specint_t(c, lam, li)

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine read_

   !****

   subroutine write_(hi, si)

      type(hdf5io_t), intent(inout) :: hi
      type(specint_t), intent(in)   :: si

      real(RD)       :: lam_min
      real(RD)       :: lam_max
      type(hdf5io_t) :: hi_li

      ! Write the specint_t

      call hi%write_attr('TYPE', 'specint_t')

      call si%inquire(lam_min=lam_min, lam_max=lam_max)

      call hi%write_attr('lam_min', lam_min)
      call hi%write_attr('lam_max', lam_max)

      call hi%write_dset('lam', si%lam)
      call hi%write_dset('c', si%c)

      hi_li = hdf5io_t(hi, 'li')
      call write(hi_li, si%li)
      call hi_li%final()

      ! Finish

      return

   end subroutine write_

end module specint_m
