! Module  : specint_m
! Purpose : define specint_t type, for representing spectral intensity
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module specint_m

   ! Uses

   use forum_m

   use limb_m
   use math_m
   use passband_m
   use photint_m
   use range_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type specint_t
      private
      real(RD), allocatable       :: c(:,:)
      real(RD), allocatable       :: lam(:)
      class(range_t), allocatable :: ra
      type(limb_t)                :: li
      integer                     :: n_b
      integer                     :: n_lam
      logical                     :: low_acc
   contains
      private
      procedure, public :: inquire
      #:for name in ('intensity', 'E_moment', 'D_moment', 'flux')
         procedure, public :: interp_${name}$
      #:endfor
      procedure         :: interp_f_
      procedure, public :: apply_passband
   end type specint_t

   ! Interfaces

   interface specint_t
      module procedure specint_t_
      module procedure specint_t_fit_
      module procedure specint_t_interp_
      module procedure specint_t_subset_
   end interface specint_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: specint_t
   public :: read
   public :: write

   ! Procedures

contains

   function specint_t_(c, ra, li, low_acc) result (si)

      real(RD), intent(in)          :: c(:,:)
      class(range_t), intent(in)    :: ra
      type(limb_t), intent(in)      :: li
      logical, intent(in), optional :: low_acc
      type(specint_t)               :: si

      logical :: low_acc_
      integer :: n_b
      integer :: n_lam 

      if (PRESENT(low_acc)) then
         low_acc_ = low_acc
      else
         low_acc_ = .FALSE.
      endif

      ! Construct the specint_t from the supplied data

      call li%inquire(n=n_b)
      call ra%inquire(n=n_lam)

      @:CHECK_BOUNDS(n_b, SIZE(c, 1))
      @:CHECK_BOUNDS(n_lam, SIZE(c, 2)+1)

      si%c = c

      allocate(si%lam(n_lam))
      call ra%get_all(si%lam)

      si%ra = ra
      si%li = li

      si%n_b = n_b
      si%n_lam = n_lam

      si%low_acc = low_acc_
      
      ! Finish

      return

   end function specint_t_

   !****

   function specint_t_fit_(I, mu, ra, li, low_acc) result (si)

      real(RD), intent(in)          :: I(:,:)
      real(RD), intent(in)          :: mu(:)
      class(range_t), intent(in)    :: ra
      type(limb_t), intent(in)      :: li
      logical, intent(in), optional :: low_acc
      type(specint_t)               :: si

      real(RD), allocatable :: c(:,:)

      ! Construct the specint_t by fitting the supplied I(mu,lambda)
      ! intensity data

      call li%fit_intensity(I, mu, c)

      si = specint_t(c, ra, li, low_acc)

      ! Finish

      return

   end function specint_t_fit_

   !****

   function specint_t_interp_(si_in, ra) result (si)

      type(specint_t), intent(inout) :: si_in
      class(range_t), intent(in)     :: ra
      type(specint_t)                :: si

      integer               :: n_lam
      real(RD), allocatable :: lam(:)
      real(RD), allocatable :: c(:,:)
      integer               :: p
      real(RD)              :: b(si_in%n_b)

      ! Construct the specint_t by interpolating the supplied
      ! specint_t onto the la abscissa

      call ra%inquire(n=n_lam)

      allocate(lam(n_lam))
      allocate(c(si_in%n_b,n_lam-1))

      call ra%get_all(lam)

      do p = 1, si_in%n_b

         b = 0._RD
         b(p) = 1._RD

         call si_in%interp_f_(b, lam, c(p,:))

      end do

      si = specint_t(c, ra, si_in%li, si_in%low_acc)

      ! Finish

      return

   end function specint_t_interp_

   !****

   function specint_t_subset_(si_in, lam_min, lam_max) result (si)

      type(specint_t), intent(in)   :: si_in
      real(RD), intent(in)          :: lam_min
      real(RD), intent(in)          :: lam_max
      type(specint_t)               :: si

      integer                     :: i_a
      integer                     :: i_b
      class(range_t), allocatable :: ra

      ! Construct the specint_t by subsetting the supplied specint_t

      call si_in%ra%locate(lam_min, i_a, right=.TRUE.)
      call si_in%ra%locate(lam_min, i_b, right=.FALSE.)

      i_a = MAX(i_a, 1)
      i_b = MIN(i_b, si_in%n_lam)

      ra = range_t(si_in%ra, i_a, i_b)

      si = specint_t(si_in%c(:,i_a:i_b-1), ra, si_in%li, si_in%low_acc)

      ! Finish

      return

   end function specint_t_subset_

   !****

   subroutine inquire(self, lam_min, lam_max, low_acc)

      class(specint_t), intent(in)    :: self
      real(RD), intent(out), optional :: lam_min
      real(RD), intent(out), optional :: lam_max
      logical, intent(out), optional  :: low_acc

      ! Inquire metadata

      if (PRESENT(lam_min)) lam_min = self%lam(1)
      if (PRESENT(lam_max)) lam_max = self%lam(self%n_lam)

      if (PRESENT(low_acc)) low_acc = self%low_acc

      ! Finish

      return

   end subroutine inquire

   !****

   #:for name, arg_var, arg_type in (('intensity', 'mu', 'real(RD)'), &
                                     ('E_moment', 'k', 'integer'), &
                                     ('D_moment', 'l', 'integer'))

      subroutine interp_${name}$(self, ${arg_var}$, lam, res, stat)

         class(specint_t), intent(in)   :: self
         ${arg_type}$, intent(in)       :: ${arg_var}$
         real(RD), intent(in)           :: lam(:)
         real(RD), intent(out)          :: res(:)
         integer, intent(out), optional :: stat

         real(RD) :: b(self%n_b)

         ! Set up the basis functions

         call self%li%eval_${name}$_basis(${arg_var}$, b, stat)
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif

         ! Do the interpolation

         call self%interp_f_(b, lam, res, stat)

         ! Finish

         return

      end subroutine interp_${name}$

   #:endfor
      
   !****

   #:for name, var in (('flux', 'F'),)

      subroutine interp_${name}$(self, lam, res, stat)

         class(specint_t), intent(in)   :: self
         real(RD), intent(in)           :: lam(:)
         real(RD), intent(out)          :: res(:)
         integer, intent(out), optional :: stat

         real(RD) :: b(self%n_b)

         ! Set up the basis functions

         call self%li%eval_${name}$_basis(b, stat)
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif

         ! Do the interpolation

         call self%interp_f_(b, lam, res, stat)

         ! Finish

         return

      end subroutine interp_${name}$

   #:endfor

   !****
      
   subroutine interp_f_(self, b, lam, f, stat)

      class(specint_t), intent(in)   :: self
      real(RD), intent(in)           :: b(:)
      real(RD), intent(in)           :: lam(:)
      real(RD), intent(out)          :: f(:)
      integer, intent(out), optional :: stat

      integer  :: n_lam
      integer  :: i
      integer  :: j
      real(RD) :: lam_a
      real(RD) :: lam_b

      @:CHECK_BOUNDS(SIZE(b), self%n_b)
      @:CHECK_BOUNDS(SIZE(f), SIZE(lam)-1)

      ! Check lam is valid

      n_lam = SIZE(lam)

      if (lam(1) < self%lam(1)) then
         if (PRESENT(stat)) then
            stat = STAT_OUT_OF_BOUNDS_LAM_LO
            return
         else
            @:ABORT('out-of-bounds (lo) lam')
         endif
      endif

      if (lam(n_lam) > self%lam(self%n_lam)) then
         if (PRESENT(stat)) then
            stat = STAT_OUT_OF_BOUNDS_LAM_HI
            return
         else
            @:ABORT('out-of-bounds (hi) lam')
         endif
      endif

      ! Perform the interpolation (conservative piecewise-constant
      ! rebin)

      call locate(self%lam, lam(1), i)

      if (i == self%n_lam) i = i - 1

      j = 1

      f = 0._RD

      interp_loop : do

         if (j >= n_lam) exit interp_loop

         lam_a = MAX(self%lam(i), lam(j))
         lam_b = MIN(self%lam(i+1), lam(j+1))

         f(j) = f(j) + (lam_b - lam_a)/(lam(j+1) - lam(j))*DOT_PRODUCT(b, self%c(:,i))

         if (lam_b == self%lam(i+1)) i = i + 1
         if (lam_b == lam(j+1)) j = j + 1

      end do interp_loop

      if (PRESENT(stat)) stat = STAT_OK

      ! Finish

      return

   end subroutine interp_f_

   !****

   subroutine apply_passband(self, pb, pi, stat)

      class(specint_t), intent(in)   :: self
      type(passband_t), intent(in)   :: pb
      type(photint_t), intent(out)   :: pi
      integer, intent(out), optional :: stat

      real(RD) :: lam_min
      real(RD) :: lam_max
      real(RD) :: lam_min_pb
      real(RD) :: lam_max_pb
      real(RD) :: c(self%n_b)
      integer  :: i
      real(RD) :: P

      ! Apply the passband, to yield a photint_t

      ! First check that the spectrum is defined across the passband support

      call self%inquire(lam_min=lam_min, lam_max=lam_max)
      call pb%inquire(lam_min=lam_min_pb, lam_max=lam_max_pb)

      if (lam_min_pb < lam_min) then
         if (PRESENT(stat)) then
            stat = STAT_OUT_OF_BOUNDS_LAM_LO
            return
         else
            @:ABORT('out-of-bounds (lo) lam')
         endif
      endif

      if (lam_max_pb > lam_max) then
         if (PRESENT(stat)) then
            stat = STAT_OUT_OF_BOUNDS_LAM_HI
            return
         else
            @:ABORT('out-of-bounds (hi) lam')
         endif
      endif

      ! Evaluate the coefficients

      c = 0._RD

      coeff_loop : do i = 1, self%n_lam-1

         ! Evaluate the passthrough

         P = pb%passthru(self%lam(i), self%lam(i+1))

         ! Add the contribution to c

         c = c + P*self%c(:,i)

      end do coeff_loop

      ! Construct the photint

      pi = photint_t(c, self%li)

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine apply_passband

   !****

   subroutine read_(hi, si, stat)

      type(hdf5io_t), intent(inout)  :: hi
      type(specint_t), intent(out)   :: si
      integer, intent(out), optional :: stat

      character(TYPE_LEN)         :: type
      real(RD), allocatable       :: c(:,:)
      type(hdf5io_t)              :: hi_ra
      class(range_t), allocatable :: ra
      type(hdf5io_t)              :: hi_li
      type(limb_t)                :: li
      logical                     :: low_acc

      character(:), allocatable :: file_name

      ! Read the specint_t

      call hi%read_attr('TYPE', type)
      if (type /= 'specint_t') then
         if (PRESENT(stat)) then
            stat = STAT_INVALID_TYPE
            return
         else
            @:ABORT('invalid type')
         endif
      endif

      call hi%read_attr('low_acc', low_acc)

      call hi%alloc_read_dset('c', c)

      call hi%inquire(file_name=file_name)

      hi_ra = hdf5io_t(hi, 'ra')
      call read(hi_ra, ra)
      call hi_ra%final()

      hi_li = hdf5io_t(hi, 'li')
      call read(hi_li, li)
      call hi_li%final()

      si = specint_t(c, ra, li, low_acc)

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine read_

   !****

   subroutine write_(hi, si, stat)

      type(hdf5io_t), intent(inout)  :: hi
      type(specint_t), intent(in)    :: si
      integer, intent(out), optional :: stat

      real(RD)       :: lam_min
      real(RD)       :: lam_max
      type(hdf5io_t) :: hi_ra
      type(hdf5io_t) :: hi_li

      ! Write the specint_t

      call hi%write_attr('TYPE', 'specint_t')

      call si%inquire(lam_min=lam_min, lam_max=lam_max)

      call hi%write_attr('lam_min', lam_min)
      call hi%write_attr('lam_max', lam_max)

      call hi%write_attr('low_acc', si%low_acc)

      hi_ra = hdf5io_t(hi, 'ra')
      call write(hi_ra, si%ra, stat)
      call hi_ra%final()
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      if (si%low_acc) then
         call hi%write_dset('c', REAL(si%c, RS))
      else
         call hi%write_dset('c', si%c)
      endif

      hi_li = hdf5io_t(hi, 'li')
      call write(hi_li, si%li, stat)
      call hi_li%final()
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      end if

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   end subroutine write_

end module specint_m
