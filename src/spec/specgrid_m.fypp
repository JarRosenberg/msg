! Module  : specgrid_m
! Purpose : define specgrid_t type, for representing spectral intensity
!           grids
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module specgrid_m

   ! Uses
   
   use forum_m

   use ngrid_m
   use passband_m
   use photint_m
   use photgrid_m
   use specint_m
   use dyn_specint_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type :: specgrid_t
      private
      class(specint_t), allocatable :: si(:)
      type(ngrid_t)                 :: ng
      real(RD)                      :: lam_min
      real(RD)                      :: lam_max
      integer, allocatable          :: shape(:)
      integer                       :: rank
   contains
      private
      procedure, public :: inquire
      #:for name in ('intensity', 'D_moment', 'flux')
         procedure, public :: interp_${name}$
      #:endfor
   end type specgrid_t

   ! Interfaces

   interface specgrid_t
      module procedure specgrid_t_
   end interface specgrid_t

   interface photgrid_t
      module procedure photgrid_t_specgrid_
   end interface photgrid_t
   
   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: specgrid_t
   public :: photgrid_t
   public :: read
   public :: write

   ! Procedures

contains

   function specgrid_t_ (si, ng) result (sg)

      class(specint_t), intent(in) :: si(:)
      type(ngrid_t), intent(in)    :: ng
      type(specgrid_t)             :: sg

      integer              :: rank
      integer, allocatable :: shape(:)
      real(RD)             :: lam_min
      real(RD)             :: lam_max

      ! Construct the specgrid_t

      call ng%inquire(rank=rank)

      allocate(shape(rank))

      call ng%inquire(shape=shape)

      @:CHECK_BOUNDS(SIZE(si), PRODUCT(shape))

      lam_min = -HUGE(0._RD)
      lam_max = HUGE(0._RD)

      call ng%map(meta_proc_)

      @:ASSERT(lam_max > lam_min,'non-overlapping wavelength ranges')
 
      allocate(sg%si, SOURCE=si)

      sg%ng = ng

      sg%lam_min = lam_min
      sg%lam_max = lam_max

      sg%shape = shape
      sg%rank = rank

      ! Finish

      return

   contains

      subroutine meta_proc_(vi, stat)

         integer, intent(in)            :: vi(:)
         integer, intent(out), optional :: stat

         integer  :: li
         real(RD) :: lam_min_i
         real(RD) :: lam_max_i

         ! Set or check metadata

         li = ng%li_from_vi(vi)

         call si(li)%inquire(lam_min=lam_min_i, lam_max=lam_max_i)

         lam_min = MAX(lam_min, lam_min_i)
         lam_max = MIN(lam_max, lam_max_i)
         
         ! Finish

         return

      end subroutine meta_proc_

   end function specgrid_t_

   !****

   subroutine inquire(self, lam_min, lam_max, shape, rank, axis_min, axis_max, axis_labels)

      class(specgrid_t), intent(in)       :: self
      real(RD), intent(out), optional     :: lam_min
      real(RD), intent(out), optional     :: lam_max
      integer, intent(out), optional      :: shape(:)
      integer, intent(out), optional      :: rank
      real(RD), intent(out), optional     :: axis_min(:)
      real(RD), intent(out), optional     :: axis_max(:)
      character(*), intent(out), optional :: axis_labels(:)

      if (PRESENT(shape)) then
         @:CHECK_BOUNDS(SIZE(shape), self%rank)
      end if

      ! Inquire metadata

      if (PRESENT(lam_min)) lam_min = self%lam_min
      if (PRESENT(lam_max)) lam_max = self%lam_max

      if (PRESENT(shape)) shape = self%shape
      if (PRESENT(rank)) rank = self%rank

      call self%ng%inquire(axis_min=axis_min, axis_max=axis_max, axis_labels=axis_labels)

      ! Finish

      return

   end subroutine inquire

   !****

   #:for name, var, arg_var, arg_type in (('intensity', 'I', 'mu', 'real(RD)'), &
                                       ('D_moment', 'D', 'l', 'integer'))

      subroutine interp_${name}$(self, vx, ${arg_var}$, lam, ${var}$, stat, vderiv)

         class(specgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: vx(:)
         ${arg_type}$, intent(in)         :: ${arg_var}$
         real(RD), intent(in)             :: lam(:)
         real(RD), intent(out)            :: ${var}$(:)
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: vderiv(:)

         ! Interpolate the data

         call self%ng%interp(proc_, vx, ${var}$, stat, vderiv)

         ! Finish

      contains

         subroutine proc_(vi, f, stat)

            integer, intent(in)            :: vi(:)
            real(RD), intent(out)          :: f(:)
            integer, intent(out), optional :: stat

            integer :: li

            li = self%ng%li_from_vi(vi)

            call self%si(li)%interp_${name}$(${arg_var}$, lam, f, stat)

            return

         end subroutine proc_

      end subroutine interp_${name}$

   #:endfor

   !****

   #:for name, var in (('flux', 'F'),)

      subroutine interp_${name}$(self, vx, lam, ${var}$, stat, vderiv)

         class(specgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: vx(:)
         real(RD), intent(in)             :: lam(:)
         real(RD), intent(out)            :: ${var}$(:)
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: vderiv(:)

         ! Interpolate the ${name}$

         call self%ng%interp(proc_, vx, ${var}$, stat, vderiv)

         ! Finish

      contains

         subroutine proc_(vi, f, stat)

            integer, intent(in)            :: vi(:)
            real(RD), intent(out)          :: f(:)
            integer, intent(out), optional :: stat

            integer :: li

            li = self%ng%li_from_vi(vi)

            call self%si(li)%interp_${name}$(lam, f, stat)

            return

         end subroutine proc_

      end subroutine interp_${name}$

   #:endfor

   !****

   function photgrid_t_specgrid_(sg, pb, norm) result(pg)

      type(specgrid_t), intent(inout) :: sg
      type(passband_t), intent(in)    :: pb
      logical, intent(in), optional   :: norm
      type(photgrid_t)                :: pg

      real(RD)                     :: lam_min
      real(RD)                     :: lam_max
      real(RD)                     :: lam_min_pb
      real(RD)                     :: lam_max_pb
      integer                      :: n_li
      type(photint_t), allocatable :: pi(:)

      ! Construct the photgrid_t from the specgrid_t

      ! First check that the specgrid is defined across the passband support

      call sg%inquire(lam_min=lam_min, lam_max=lam_max)
      call pb%get_support(lam_min_pb, lam_max_pb)

      @:ASSERT(lam_min_pb <= lam_min, 'specgrid does not span passband support')
      @:ASSERT(lam_max_pb >= lam_max, 'specgrid does not span passband support')

      ! Evaluate the photint_t data

      n_li = PRODUCT(sg%shape)

      allocate(pi(n_li))

      call sg%ng%map(photint_proc_)

      ! Create the photgrid_t

      pg = photgrid_t(pi, sg%ng)

      ! Finish

      return

   contains

      subroutine photint_proc_(vi, stat)

         integer, intent(in)            :: vi(:)
         integer, intent(out), optional :: stat

         integer  :: li

         ! Construct the photint_t
         
         li = sg%ng%li_from_vi(vi)

         pi(li) = photint_t(sg%si(li), pb)

         ! Finish

         return

      end subroutine photint_proc_

   end function photgrid_t_specgrid_

   !****

   subroutine read_(hi, sg, stat)

      type(hdf5io_t), intent(inout)  :: hi
      type(specgrid_t), intent(out)  :: sg
      integer, intent(out), optional :: stat

      character(TYPE_LEN)              :: type
      integer, allocatable             :: shape(:)
      type(hdf5io_t)                   :: hi_ng
      type(ngrid_t)                    :: ng
      integer                          :: n_si
      type(dyn_specint_t), allocatable :: si(:)

      ! Read the specgrid_t

      call hi%read_attr('TYPE', type)
      if (type /= 'specgrid_t') then
         if (PRESENT(stat)) then
            stat = STAT_INVALID_TYPE
            return
         else
            @:ABORT('invalid type')
         endif
      endif

      call hi%alloc_read_attr('shape', shape)
      
      hi_ng = hdf5io_t(hi, 'ng')
      call read(hi_ng, ng)
      call hi_ng%final()

      n_si = PRODUCT(shape)

      allocate(si(n_si))

      call ng%map(read_specint_)

      sg = specgrid_t(si, ng)

      ! Finish

      if (PRESENT(stat)) stat = STAT_OK

      return

   contains

      subroutine read_specint_(vi, stat)

         integer, intent(in)            :: vi(:)
         integer, intent(out), optional :: stat

         integer        :: li
         type(hdf5io_t) :: hi_si

         ! Read the specint_t for the node

         li = ng%li_from_vi(vi)
 
         hi_si = hdf5io_t(hi, si_name_(li))
         call read(hi_si, si(li))
         call hi_si%final()

         ! Finish

         return

      end subroutine read_specint_
            
   end subroutine read_

   !****

   subroutine write_(hi, sg)

      type(hdf5io_t), intent(inout)   :: hi
      type(specgrid_t), intent(inout) :: sg

      type(hdf5io_t) :: hi_ng

      ! Write the specgrid_t

      call hi%write_attr('TYPE', 'specgrid_t')

      call hi%write_attr('shape', sg%shape)
      call hi%write_attr('rank', sg%rank)

      hi_ng = hdf5io_t(hi, 'ng')
      call write(hi_ng, sg%ng)
      call hi_ng%final()

      call sg%ng%map(write_specint_)

      ! Finish

      return

   contains

      subroutine write_specint_(vi, stat)

         integer, intent(in)            :: vi(:)
         integer, intent(out), optional :: stat

         integer        :: li
         type(hdf5io_t) :: hi_si

         ! Write the specint_t for the node

         li = sg%ng%li_from_vi(vi)
 
         hi_si = hdf5io_t(hi, si_name_(li))

         select type (si => sg%si)
         type is (specint_t)
            call write(hi_si, si(li))
         type is (dyn_specint_t)
            call write(hi_si, si(li))
         end select
            
         call hi_si%final()

         ! Finish

         return

      end subroutine write_specint_

   end subroutine write_

   !****

   function si_name_(li) result (name)

      integer, intent(in) :: li
      character(256)      :: name

      write(name, 100) li
100   format('si(',I0,')')

   end function si_name_

end module specgrid_m
