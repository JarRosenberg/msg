! Module  : dyn_radint_m
! Purpose : define dyn_radint_t type, for representing dynamically-loadable
!           radiant intensity
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module dyn_radint_m

   ! Uses

   use kinds_m
   use hdf5io_m

   use radint_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type, extends(radint_t) :: dyn_radint_t
      private
      procedure(process_radint), nopass, pointer :: process => null()
      type(hdf5io_t)                             :: hi
      logical                                    :: loaded
   contains
      private
      procedure, public :: eval_intensity
      procedure, public :: eval_D_moment
      procedure, public :: eval_flux
      procedure         :: load_
   end type dyn_radint_t

   ! Interfaces

   interface read
      module procedure read_
   end interface read

   ! Access specifiers

   private

   public :: dyn_radint_t
   public :: read

   ! Procedures

contains

   #:for name, var, arg_var, arg_type in (('intensity', 'I', 'mu', 'real(RD)'), &
                                          ('D_moment', 'D', 'l', 'integer'))

      subroutine eval_${name}$(self, ${arg_var}$, k_a, k_b, ${var}$, stat)

         class(dyn_radint_t), intent(inout) :: self
         ${arg_type}$, intent(in)           :: ${arg_var}$
         integer, intent(in)                :: k_a
         integer, intent(in)                :: k_b
         real(RD)                           :: ${var}$(:)
         integer, intent(out), optional     :: stat

         ! If necessary, load

         if (.NOT. self%loaded) call self%load_()
         
         ! Pass

         call self%radint_t%eval_${name}$(${arg_var}$, k_a, k_b, ${var}$, stat)

         ! Finish

         return

      end subroutine eval_${name}$

   #:endfor
      
   !****

   #:for name, var in (('flux', 'F'), )

      subroutine eval_${name}$(self, k_a, k_b, ${var}$, stat)

         class(dyn_radint_t), intent(inout) :: self
         integer, intent(in)                :: k_a
         integer, intent(in)                :: k_b
         real(RD)                           :: ${var}$(:)
         integer, intent(out), optional     :: stat

         ! If necessary, load

         if (.NOT. self%loaded) call self%load_()
         
         ! Pass

         call self%radint_t%eval_${name}$(k_a, k_b, ${var}$, stat)

         ! Finish

         return

      end subroutine eval_${name}$

   #:endfor

   !****

   subroutine load_ (self)
      
      class(dyn_radint_t), intent(inout) :: self

      ! Load the radint

      call read(self%hi, self%radint_t, self%process)

      self%loaded = .TRUE.

      ! Finish

      return

   end subroutine load_

   !****

   subroutine read_(hi, ri, process)

      type(hdf5io_t), intent(inout)       :: hi
      type(dyn_radint_t), intent(out)     :: ri
      procedure(process_radint), optional :: process

      ! Read the dyn_radint_t (this only sets variables used in a
      ! later call to load_)

      if (PRESENT(process)) ri%process => process

      ri%hi = hdf5io_t(hi, '.')

      call ri%hi%read_attr('n_k', ri%n_k)

      ri%loaded = .FALSE.

      ! Finish

      return

   end subroutine read_

end module dyn_radint_m
