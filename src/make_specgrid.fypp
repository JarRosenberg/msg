! Module   : make_specgrid
! Purpose  : create specgrid files from radint files
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

program make_specgrid

   ! Uses

   use kinds_m
   use hdf5io_m
   use order_m
   use system_m

   use radint_m
   use radgrid_m
   use specgrid_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Variables

   character(:), allocatable :: list_filename
   character(:), allocatable :: specgrid_filename

   type(radint_t), allocatable :: ri(:,:)
   logical, allocatable        :: mask(:,:)
   real(RD), allocatable       :: logT(:)
   real(RD), allocatable       :: logg(:)
   integer                     :: n_k
   real(RD)                    :: w_0
   real(RD)                    :: dw
   integer                     :: n_logT
   integer                     :: n_logg
   integer                     :: j
   type(specgrid_t)            :: sg
   type(hdf5io_t)              :: hi

   ! Read command-line arguments

   @:ASSERT(n_arg() == 2,{Syntax: make_specgrid list_filename specgrid_filename})

   call get_arg(1, list_filename)
   call get_arg(2, specgrid_filename)

   ! Read the radint_t grid

   call read_radint_grid(list_filename, ri, mask, logT, logg, n_k, w_0, dw)

   ! Print out grid architecture

   n_logT = SIZE(logT)
   n_logg = SIZE(logg)

   print 100, NINT(10**logT(1)), REPEAT(' ', n_logT-9), NINT(10**logT(n_logT))
100 format(5X,I4,A,I5)

   do j = n_logg, 1, -1
      print 110, logg(j), MERGE('X', '.', mask(:,j))
110   format(F4.2,1X,9999A1)
   end do

   ! Create the specgrid_t

   sg = specgrid_t(radgrid_t(ri, mask, logT, logg, n_k), w_0, dw)

   ! Write it

   hi = hdf5io_t(specgrid_filename, CREATE_FILE)
   call write(hi, sg)
   call hi%final()

   ! Finish

contains

   subroutine read_radint_grid (list_filename, ri, mask, logT, logg, n_k, w_0, dw)

      character(*), intent(in)                 :: list_filename
      type(radint_t), allocatable, intent(out) :: ri(:,:)
      logical, allocatable, intent(out)        :: mask(:,:)
      real(RD), allocatable, intent(out)       :: logT(:)
      real(RD), allocatable, intent(out)       :: logg(:)
      integer, intent(out)                     :: n_k
      real(RD), intent(out)                    :: w_0
      real(RD), intent(out)                    :: dw

      integer                     :: unit
      integer                     :: n_node
      character(256), allocatable :: node_filename(:)
      real(RD), allocatable       :: node_logT(:)
      real(RD), allocatable       :: node_logg(:)
      integer                     :: l
      real(RD)                    :: Teff
      integer                     :: n_logT
      integer                     :: n_logg
      integer                     :: i
      integer                     :: j
      type(hdf5io_t)              :: hi
      integer                     :: node_n_k
      real(RD)                    :: node_w_0
      real(RD)                    :: node_dw

      ! Open the file listing the grid nodes

      open(NEWUNIT=unit, FILE=list_filename, STATUS='OLD')

      ! Count lines

      n_node = 0

      count_loop : do
         read(unit, *, END=100)
         n_node = n_node + 1
      end do count_loop

100   continue

      ! Read data

      rewind(unit)

      allocate(node_filename(n_node))

      allocate(node_logT(n_node))
      allocate(node_logg(n_node))

      read_loop : do l = 1, n_node
         read(unit, *) Teff, node_logg(l), node_filename(l)
         node_logT(l) = LOG10(Teff)
      end do read_loop

      close(unit)

      ! Extract the logT and logg axes

      logT = node_logT(unique_indices(node_logT))
      logg = node_logg(unique_indices(node_logg))

      ! Allocate arrays

      n_logT = SIZE(logT)
      n_logg = SIZE(logg)

      allocate(ri(n_logT,n_logg))
      allocate(mask(n_logT,n_logg))

      mask = .FALSE.

      ! Read in the radint_t's

      radint_loop : do l = 1, n_node

         i = FINDLOC(logT, node_logT(l), DIM=1)
         j = FINDLOC(logg, node_logg(l), DIM=1)

         @:ASSERT(i >= 1 .AND. i <= n_logT, unable to locate node in grid)
         @:ASSERT(j >= 1 .AND. j <= n_logg, unable to locate node in grid)
         @:ASSERT(.NOT. mask(i,j), duplicate node)

         hi = hdf5io_t(node_filename(l), OPEN_FILE)

         @:ASSERT(hi%attr_exists('w_0'), radint file lacks w_0 data)
         @:ASSERT(hi%attr_exists('dw'), radint file lacks dw data)

         call hi%read_attr('w_0', node_w_0)
         call hi%read_attr('dw', node_dw)

         call read(hi, ri(i,j))

         node_n_k = ri(i,j)%n_k

         call hi%final()

         if (l == 1) then
            n_k = node_n_k
            w_0 = node_w_0
            dw = node_dw
         else
            @:ASSERT(node_n_k == n_k, n_k mismatch)
            @:ASSERT(node_w_0 == w_0, w_0 mismatch)
            @:ASSERT(node_dw == dw, dw mismatch)
         endif

         mask(i,j) = .TRUE.

      end do radint_loop

      ! Finish

   end subroutine read_radint_grid

end program make_specgrid
