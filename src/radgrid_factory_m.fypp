! Module   : radgrid_factory_m
! Purpose  : factory procedures for radgrid_t type
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module radgrid_factory_m

  ! Uses
  
   use kinds_m
   
   use radint_m
   use radnode_m
   use radgrid_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Access specifiers

   private

   public :: radgrid_from_grid

   ! Procedures

contains

   function radgrid_from_grid(ri, mask, lnT, lng) result (rg)

      type(radint_t), intent(in) :: ri(:,:)
      logical, intent(in)        :: mask(:,:)
      real(RD), intent(in)       :: lnT(:)
      real(RD), intent(in)       :: lng(:)
      type(radgrid_t)            :: rg

      integer                      :: n_lnT
      integer                      :: n_lng
      real(RD), allocatable        :: lnT_g(:)
      real(RD), allocatable        :: lng_g(:)
      type(radint_t), allocatable  :: ri_g(:,:)
      logical, allocatable         :: mask_g(:,:)
      type(radnode_t), allocatable :: rn(:,:)
      logical, allocatable         :: mask_rn(:,:)
      integer                      :: i
      integer                      :: j
      
      @:CHECK_BOUNDS(SIZE(mask, 1), SIZE(ri, 1))
      @:CHECK_BOUNDS(SIZE(mask, 2), SIZE(ri, 2))

      @:CHECK_BOUNDS(SIZE(lnT), SIZE(ri, 1))
      @:CHECK_BOUNDS(SIZE(lng), SIZE(ri, 2))

      ! Construct the radgrid_t from the grid of radint_t's

      ! Add ghost zones to the grid

      n_lnT = SIZE(lnT)
      n_lng = SIZE(lng)

      allocate(lnT_g(0:n_lnT+1))
      allocate(lng_g(0:n_lng+1))

      lnT_g(1:n_lnT) = lnT
      lng_g(1:n_lng) = lng

      allocate(ri_g(0:n_lnT+1,0:n_lng+1))
      allocate(mask_g(0:n_lnT+1,0:n_lng+1))

      ri_g(1:n_lnT,1:n_lng) = ri

      mask_g(1:n_lnT,1:n_lng) = mask
      mask_g(0,:) = .FALSE.
      mask_g(n_lnT+1,:) = .FALSE.
      mask_g(:,0) = .FALSE.
      mask_g(:,n_lng+1) = .FALSE.

      ! Allocate space for the radnode_t's and their mask

      allocate(rn(n_lnT,n_lng))
      allocate(mask_rn(n_lnT,n_lng))

      mask_rn = .FALSE.

      ! For each masked-in node in the grid, set up the radnode_t

      lnT_loop : do i = 1, n_lnT
         lng_loop : do j = 1, n_lng

            if (mask(i,j)) then

               ! Evaluate derivatives

               eval_block : block

                  logical        :: deriv_ok
                  type(radint_t) :: dri_dlnT
                  type(radint_t) :: dri_dlng
                  type(radint_t) :: d2ri_dlnTdlng
                  
                  call eval_first_deriv_(ri_g(i-1:i+1,j), mask_g(i-1:i+1,j), lnT_g(i-1:i+1), dri_dlnT, deriv_ok)
                  if (.NOT. deriv_ok) exit eval_block

                  call eval_first_deriv_(ri_g(i,j-1:j+1), mask_g(i,j-1:j+1), lnT_g(j-1:j+1), dri_dlng, deriv_ok)
                  if (.NOT. deriv_ok) exit eval_block

                  call eval_cross_deriv_(ri_g(i-1:i+1,j-1:j+1), mask_g(i-1:i+1,j-1:j+1), &
                       lnT_g(i-1:i+1), lng_g(j-1:j+1), d2ri_dlnTdlng, deriv_ok)
                  if (.NOT. deriv_ok) exit eval_block

                  ! Set up the radnode

                  rn(i,j) = radnode_t(ri(i,j), dri_dlnT, dri_dlng, d2ri_dlnTdlng)
                  mask_rn(i,j) = .TRUE.

                end block eval_block

            end if

         end do lng_loop
      end do lnT_loop

      ! Print out grid architecture

      print 100, NINT(exp(lnT(1))), REPEAT(' ', n_lnT-9), NINT(exp(lnT(n_lnT)))
100   format(5X,I4,A,I5)

      do j = n_lng, 1, -1
         print 110, lng(j)/log(10._RD), MERGE('X', '.', mask_rn(:,j))
110      format(F4.2,1X,9999A1)
      end do

      ! Construct the radgrid_t

      rg = radgrid_t(rn, mask_rn, lnT, lng)

      ! Finish

      return

   end function radgrid_from_grid

   !****

   subroutine eval_first_deriv_ (ri, mask, x, dri_dx, deriv_ok)

      type(radint_t), intent(in)  :: ri(:)
      logical, intent(in)         :: mask(:)
      real(RD), intent(in)        :: x(:)
      type(radint_t), intent(out) :: dri_dx
      logical, intent(out)        :: deriv_ok

      logical        :: mask_fd(2)
      type(radint_t) :: dri_fd(2)
      real(RD)       :: u

      ! Evaluate the first derivative

      ! Set up finite differences

      if (mask(1)) then
         mask_fd(1) = .TRUE.
         dri_fd(1) = (ri(2) - ri(1))/(x(2) - x(1))
      else
         mask_fd(1) = .FALSE.
      endif

      if (mask(3)) then
         mask_fd(2) = .TRUE.
         dri_fd(2) = (ri(3) - ri(2))/(x(3) - x(2))
      else
         mask_fd(2) = .FALSE.
      endif

      ! Blend them to create the first derivative

      select case (COUNT(mask_fd))
      case (1)
         if (mask_fd(1)) then
            dri_dx = dri_fd(1)
         else
            dri_dx = dri_fd(2)
         endif
         deriv_ok = .TRUE.
      case (2)
         u = (x(2) - x(1))/(x(3) - x(1))
         dri_dx = (1._RD-u)*dri_fd(1) + u*dri_fd(2)
         deriv_ok = .TRUE.
      case default
         deriv_ok = .FALSE.
      end select

      ! Finish

      return

   end subroutine eval_first_deriv_

   !****

   subroutine eval_cross_deriv_ (ri, mask, x, y, d2ri_dxdy, deriv_ok)

      type(radint_t), intent(in)  :: ri(:,:)
      logical, intent(in)         :: mask(:,:)
      real(RD), intent(in)        :: x(:)
      real(RD), intent(in)        :: y(:)
      type(radint_t), intent(out) :: d2ri_dxdy
      logical, intent(out)        :: deriv_ok

      logical        :: mask_fd(4)
      type(radint_t) :: d2ri_fd(4)
      real(RD)       :: u
      real(RD)       :: v

      ! Evaluate the cross derivative

      ! Set up finite differences

      if (ALL(mask(1:2,1:2))) then
         mask_fd(1) = .TRUE.
         d2ri_fd(1) = (ri(1,1) + ri(2,2) - ri(2,1) - ri(1,2))/((x(2) - x(1))*(y(2) - y(1)))
      else
         mask_fd(1) = .FALSE.
      endif

      if (ALL(mask(2:3,1:2))) then
         mask_fd(2) = .TRUE.
         d2ri_fd(2) = (ri(2,1) + ri(3,2) - ri(3,1) - ri(2,2))/((x(3) - x(2))*(y(2) - y(1)))
      else
         mask_fd(2) = .FALSE.
      endif

      if (ALL(mask(1:2,2:3))) then
         mask_fd(3) = .TRUE.
         d2ri_fd(3) = (ri(1,2) + ri(2,3) - ri(2,2) - ri(1,3))/((x(2) - x(1))*(y(3) - y(2)))
      else
         mask_fd(3) = .FALSE.
      endif

      if (ALL(mask(2:3,2:3))) then
         mask_fd(4) = .TRUE.
         d2ri_fd(4) = (ri(2,2) + ri(3,3) - ri(3,2) - ri(2,3))/((x(3) - x(2))*(y(3) - y(2)))
      else
         mask_fd(4) = .FALSE.
      endif

      ! Blend them to create the first derivative

      select case (COUNT(mask_fd))
      case (1)
         if (mask_fd(1)) then
            d2ri_dxdy = d2ri_fd(1)
         elseif (mask_fd(2)) then
            d2ri_dxdy = d2ri_fd(2)
         elseif (mask_fd(3)) then
            d2ri_dxdy = d2ri_fd(3)
         else
            d2ri_dxdy = d2ri_fd(4)
         endif
         deriv_ok = .TRUE.
      case (2)
         if (mask_fd(1) .AND. mask_fd(2)) then
            u = (x(2) - x(1))/(x(3) - x(1))
            d2ri_dxdy = (1._RD-u)*d2ri_fd(1) + u*d2ri_fd(2)
            deriv_ok = .TRUE.
         elseif (mask_fd(3) .AND. mask_fd(4)) then
            u = (x(2) - x(1))/(x(3) - x(1))
            d2ri_dxdy = (1._RD-u)*d2ri_fd(3) + u*d2ri_fd(4) 
            deriv_ok = .TRUE.
         elseif (mask_fd(1) .AND. mask_fd(3)) then
            v = (y(2) - y(1))/(y(3) - y(1))
            d2ri_dxdy = (1._RD-v)*d2ri_fd(1) + v*d2ri_fd(3)
            deriv_ok = .TRUE.
         elseif (mask_fd(2) .AND. mask_fd(4)) then
            v = (y(2) - y(1))/(y(3) - y(1))
            d2ri_dxdy = (1._RD-v)*d2ri_fd(2) + v*d2ri_fd(4)
            deriv_ok = .TRUE.
         else
            deriv_ok =.FALSE.
         end if
      case (3)
         if (.NOT. mask_fd(1)) then
            d2ri_dxdy = d2ri_fd(4)
         elseif (.NOT. mask_fd(2)) then
            d2ri_dxdy = d2ri_fd(3)
         elseif (.NOT. mask_fd(3)) then
            d2ri_dxdy = d2ri_fd(2)
         else
            d2ri_dxdy = d2ri_fd(1)
         endif
         deriv_ok = .TRUE.
      case (4)
         u = (x(2) - x(1))/(x(3) - x(1))
         v = (y(2) - y(1))/(y(3) - y(1))
         d2ri_dxdy = &
              (1._RD-u)*(1._RD-v)*d2ri_fd(1) + &
              (      u)*(1._RD-v)*d2ri_fd(2) + &
              (1._RD-u)*(      v)*d2ri_fd(3) + &
              (      u)*(      v)*d2ri_fd(4)
         deriv_ok = .TRUE.
      case default
         deriv_ok = .FALSE.
      end select

      ! Finish

      return

    end subroutine eval_cross_deriv_

end module radgrid_factory_m
         
         
         

      

      
