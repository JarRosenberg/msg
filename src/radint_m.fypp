! Module  : radint_m
! Purpose : define radint_t type, for representing radiant intensity
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module radint_m

   ! Uses

   use kinds_m
   use hdf5io_m

   use limb_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type radint_t
      private
      type(limb_t)          :: li
      real(RD), allocatable :: c(:,:)
      integer               :: n_b
      integer, public       :: n_k
   contains
      private
      procedure, public :: eval_intensity
      procedure, public :: eval_D_moment
      procedure, public :: eval_flux
   end type radint_t

   ! Interfaces

   interface radint_t
      module procedure radint_t_
      module procedure radint_t_fit_
   end interface radint_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: radint_t
   public :: read
   public :: write

   ! Procedures

contains

   function radint_t_(c, li) result (ri)

      real(RD), intent(in)     :: c(:,:)
      type(limb_t), intent(in) :: li
      type(radint_t)           :: ri

      integer :: n_b
      integer :: n_k

      ! Construct the radint_t from the supplied data

      n_b = li%n_basis()
      n_k = SIZE(c, 2)

      @:CHECK_BOUNDS(SIZE(c, 1), n_b)

      ri%li = li
      ri%c = c

      ri%n_b = n_b
      ri%n_k = n_k

      ! Finish

      return

   end function radint_t_

   !****

   function radint_t_fit_(I, mu, li) result (ri)

      real(RD), intent(in)     :: I(:,:)
      real(RD), intent(in)     :: mu(:)
      type(limb_t), intent(in) :: li
      type(radint_t)           :: ri

      real(RD), allocatable :: c(:,:)

      ! Construct the radint_t by fitting the supplied I(mu,k)
      ! intensity data

      call li%fit_intensity(I, mu, c)

      ri = radint_t(c, li)

      ! Finish

      return

   end function radint_t_fit_

   !****

   #:for name, var, arg_var, arg_type in (('intensity', 'I', 'mu', 'real(RD)'), &
                                          ('D_moment', 'D', 'l', 'integer'))

      subroutine eval_${name}$(self, ${arg_var}$, k_a, k_b, ${var}$, stat)

         class(radint_t), intent(inout) :: self
         ${arg_type}$, intent(in)       :: ${arg_var}$
         integer, intent(in)            :: k_a
         integer, intent(in)            :: k_b
         real(RD)                       :: ${var}$(:)
         integer, intent(out), optional :: stat

         real(RD) :: b(self%n_b)

         @:CHECK_BOUNDS(SIZE(${var}$), k_b-k_a+1)

         ! Check the k range

         if (k_a < 1 .OR. k_a > self%n_k) then
            if (PRESENT(stat)) then
               stat = STAT_OUT_OF_BOUNDS
               return
            else
               @:ABORT(out-of-bounds)
            endif
         endif

         if (k_b < 1 .OR. k_b > self%n_k) then
            if (PRESENT(stat)) then
               stat = STAT_OUT_OF_BOUNDS
               return
            else
               @:ABORT(out-of-bounds)
            endif
         endif

         ! Set up the basis functions

         call self%li%eval_${name}$_basis(${arg_var}$, b, stat)
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif

         ! Evaluate the ${name}$

         ${var}$ = MATMUL(b, self%c(:,k_a:k_b))

         if (PRESENT(stat)) stat = STAT_OK

         ! Finish

         return

      end subroutine eval_${name}$

   #:endfor
      
   !****

   #:for name, var in (('flux', 'F'), )

      subroutine eval_${name}$(self, k_a, k_b, ${var}$, stat)

         class(radint_t), intent(inout) :: self
         integer, intent(in)            :: k_a
         integer, intent(in)            :: k_b
         real(RD)                       :: ${var}$(:)
         integer, intent(out), optional :: stat

         real(RD) :: b(self%n_b)

         @:CHECK_BOUNDS(SIZE(${var}$), k_b-k_a+1)

         ! Set up the basis functions

         call self%li%eval_${name}$_basis(b, stat)
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif

         ! Evaluate the ${name}$

         ${var}$ = MATMUL(b, self%c(:,k_a:k_b))

         if (PRESENT(stat)) stat = STAT_OK

         ! Finish

         return

      end subroutine eval_${name}$

   #:endfor

   !****

   subroutine read_(hi, ri)

      type(hdf5io_t), intent(inout) :: hi
      type(radint_t), intent(out)   :: ri

      character(TYPE_LEN)   :: type
      real(RD), allocatable :: c(:,:)
      real(RD), allocatable :: a_f(:)
      real(RD)              :: I_1_f
      real(RD), allocatable :: a(:,:)
      real(RD), allocatable :: I_1(:)
      integer               :: n_b
      integer               :: n_k
      integer               :: k
      type(hdf5io_t)        :: hi_li
      type(limb_t)          :: li

      ! Read the radint_t

      call hi%read_attr('TYPE', type)

      if (type == 'radint_t') then

         if (hi%dset_exists('c')) then

            call hi%alloc_read_dset('c', c)

         else

            call hi%alloc_read_dset('a', a_f)
            call hi%read_dset('I_1', I_1_f)

            n_b = SIZE(a_f) + 1

            allocate(c(n_b,1))

            c(1,1) = I_1_f
            c(2:,1) = -I_1_f*a_f

         endif

      else if(type == 'specint_t') then

         call hi%alloc_read_dset('a', a)
         call hi%alloc_read_dset('I_1', I_1)

         n_b = SIZE(a, 1) + 1
         n_k = SIZE(a, 2)

         allocate(c(n_b,n_k))

         c_loop : do k = 1, n_k
            c(1,k) = I_1(k)
            c(2:,k) = -I_1(k)*a(:,k)
         end do c_loop

       else

         @:ABORT(invalid type)

      endif

      hi_li = hdf5io_t(hi, 'li')
      call read(hi_li, li)
      call hi_li%final()

      ri = radint_t(c, li)

      ! Finish

      return

   end subroutine read_

   !****

   subroutine write_ (hi, ri)

      type(hdf5io_t), intent(inout) :: hi
      type(radint_t), intent(in)    :: ri

      type(hdf5io_t) :: hi_li

      ! Write the radint_t

      call hi%write_attr('TYPE', 'radint_t')

      call hi%write_attr('n_b', ri%n_b)
      call hi%write_attr('n_k', ri%n_k)

      call hi%write_dset('c', ri%c)

      hi_li = hdf5io_t(hi, 'li')
      call write(hi_li, ri%li)
      call hi_li%final()

      ! Finish

      return

   end subroutine write_

end module radint_m
