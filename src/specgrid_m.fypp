! Module  : specgrid_m
! Purpose : define specgrid_t type, for representing spectral intensity
!           grids
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module specgrid_m

   ! Uses
   
   use kinds_m
   use hdf5io_m
   use order_m

   use radint_m
   use dyn_radint_m
   use radgrid_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type, extends(radgrid_t) :: specgrid_t
      private
      real(RD) :: w_0
      real(RD) :: dw
   contains
      private
      #:for name in ('intensity', 'D_moment', 'flux')
         procedure         :: interp_${name}$_w_
         generic, public   :: interp_${name}$ => interp_${name}$_w_
      #:endfor
   end type specgrid_t

   ! Interfaces

   interface specgrid_t
      module procedure specgrid_t_
   end interface specgrid_t

   interface read
      module procedure read_
      module procedure read_rebin_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: specgrid_t
   public :: read
   public :: write

   ! Procedures

contains

   function specgrid_t_ (rg, w_0, dw) result (sg)

      type(radgrid_t), intent(in) :: rg
      real(RD), intent(in)        :: w_0
      real(RD), intent(in)        :: dw
      type(specgrid_t)            :: sg

      ! Construct the specgrid_t

      sg%radgrid_t = rg

      sg%w_0 = w_0
      sg%dw = dw

      ! Finish

      return

   end function specgrid_t_

   !****

   #:for name, var, arg_var, arg_type in (('intensity', 'I', 'mu', 'real(RD)'), &
                                          ('D_moment', 'D', 'l', 'integer'))

      subroutine interp_${name}$_w_(self, logT, logg, ${arg_var}$, w_0, n_w, ${var}$, stat, d_dlogT, d_dlogg)

         class(specgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: logT
         real(RD), intent(in)             :: logg
         ${arg_type}$, intent(in)         :: ${arg_var}$
         real(RD), intent(in)             :: w_0
         integer, intent(in)              :: n_w
         real(RD), intent(out)            :: ${var}$(:)
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: d_dlogT
         logical, intent(in), optional    :: d_dlogg

         integer  :: k_a
         integer  :: k_b
         real(RD) :: u
         real(RD) :: ${var}$_x(n_w+1)

         ! Interpolate the ${name}$

         call locate_w_(self%w_0, self%dw, w_0, k_a, u)
         k_b = k_a + n_w

         call self%interp_${name}$(logT, logg, ${arg_var}$, k_a, k_b, ${var}$_x, stat, d_dlogT, d_dlogg)
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif

         ${var}$ = (1._RD-u)*${var}$_x(1:n_w-1) + u*${var}$_x(2:n_w)

         ! Finish

      end subroutine interp_${name}$_w_

   #:endfor

   !****

   #:for name, var in (('flux', 'F'), )

      subroutine interp_${name}$_w_(self, logT, logg, w_0, n_w, ${var}$, stat, d_dlogT, d_dlogg)

         class(specgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: logT
         real(RD), intent(in)             :: logg
         real(RD), intent(in)             :: w_0
         integer, intent(in)              :: n_w
         real(RD), intent(out)            :: ${var}$(:)
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: d_dlogT
         logical, intent(in), optional    :: d_dlogg

         integer  :: k_a
         integer  :: k_b
         real(RD) :: u
         real(RD) :: ${var}$_x(n_w+1)

         ! Interpolate the ${name}$

         call locate_w_(self%w_0, self%dw, w_0, k_a, u)
         k_b = k_a + n_w

         call self%interp_${name}$(logT, logg, k_a, k_b, ${var}$_x, stat, d_dlogT, d_dlogg)
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif

         ${var}$ = (1._RD-u)*${var}$_x(1:n_w-1) + u*${var}$_x(2:n_w)

      end subroutine interp_${name}$_w_

   #:endfor

   !****

   subroutine locate_w_(w_0, dw, w, k, u)

      real(RD), intent(in)  :: w_0
      real(RD), intent(in)  :: dw
      real(RD), intent(in)  :: w
      integer, intent(out)  :: k
      real(RD), intent(out) :: u

      real(RD) :: w_pri

      ! Locate k such that (k-1)*self%dw <= w' < k*self%dw,
      ! where w' = w - self%w_0

      w_pri = w - w_0

      k = FLOOR(w_pri/dw) + 1

      ! Set up the associated interpolation weight

      u = w_pri/dw - (k-1)

      ! Finish

      return

   end subroutine locate_w_

   !****

   subroutine read_(hi, sg, process)

      type(hdf5io_t), intent(inout)       :: hi
      type(specgrid_t), intent(out)       :: sg
      procedure(process_radint), optional :: process

      type(radgrid_t) :: rg
      real(RD)        :: w_0
      real(RD)        :: dw

      ! Read the specgrid_t

      call hi%read_attr('w_0', w_0)
      call hi%read_attr('dw', dw)

      call read(hi, rg, type='specgrid_t', process=process)

      sg = specgrid_t(rg, w_0, dw)

      ! Finish

      return

   end subroutine read_

   !****

   subroutine read_rebin_(hi, sg, n_w, w_0, dw, process)

      type(hdf5io_t), intent(inout)       :: hi
      type(specgrid_t), intent(out)       :: sg
      integer, intent(in)                 :: n_w
      real(RD), intent(in)                :: w_0
      real(RD), intent(in)                :: dw
      procedure(process_radint), optional :: process

      type(radgrid_t) :: rg
      integer         :: n_k_in
      real(RD)        :: w_0_in
      real(RD)        :: dw_in

      ! Read the specgrid_t

      call hi%read_attr('n_k', n_k_in)
      call hi%read_attr('w_0', w_0_in)
      call hi%read_attr('dw', dw_in)

      call read(hi, rg, type='specgrid_t', process=rebin_process_)

      sg = specgrid_t(rg, w_0, dw)

      ! Finish

      return

   contains

      subroutine rebin_process_(ri)

         type(radint_t), intent(inout) :: ri

         ! Rebin the radint_t

         ri = radint_t(ri, rebin_func_, n_w)

         if (PRESENT(process)) then
            call process(ri)
         endif

         ! Finish

         return

      end subroutine rebin_process_

      !****

      function rebin_func_(k_in, k) result(C)

         integer, intent(in) :: k_in
         integer, intent(in) :: k
         real(RD)            :: C

         real(RD) :: w_a
         real(RD) :: w_b
         integer  :: k_in_a
         integer  :: k_in_b
         real(RD) :: u_a
         real(RD) :: u_b
         real(RD) :: delta_in
         real(RD) :: delta

         ! Set up w-bounds of the k'th cell in ri
         
         w_a = w_0 + (k-1)*dw
         w_b = w_0 + (k  )*dw

         ! Locate where these bounds occur in ri_in

         call locate_w_(w_0_in, dw_in, w_a, k_in_a, u_a)
         call locate_w_(w_0_in, dw_in, w_b, k_in_b, u_b)

         ! Evaluate the contribution from the k_in cell

         if (k_in == k_in_a .AND. k_in == k_in_b) then
            C = u_b - u_a
         elseif (k_in == k_in_a) then
            C = 1._RD - u_a
         elseif (k_in == k_in_b) then
            C = u_b
         elseif (k_in > k_in_a .AND. k_in < k_in_b) then
            C = 1._RD
         else
            C = 0._RD
         endif
            
         ! Rescale by cell widths (done this way to avoid rounding issues)

         delta_in = (w_0_in + (k_in+1)*dw_in) - (w_0_in + (k_in  )*dw)
         delta = w_b - w_a

         C = C*delta_in/delta

         ! Finish

         return

      end function rebin_func_

   end subroutine read_rebin_
         
   !****

   subroutine write_(hi, sg)

      type(hdf5io_t), intent(inout) :: hi
      type(specgrid_t), intent(in ) :: sg

      call write(hi, sg%radgrid_t, type='specgrid_t')

      call hi%write_attr('w_0', sg%w_0)
      call hi%write_attr('dw', sg%dw)

      ! Finish

      return

   end subroutine write_

end module specgrid_m
