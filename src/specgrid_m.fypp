! Module  : specgrid_m
! Purpose : define specgrid_t type, for representing spectral intensity
!           grids
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module specgrid_m

   ! Uses
   
   use kinds_m
   use hdf5io_m
   use order_m

   use radint_m
   use dyn_radint_m
   use radgrid_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type, extends(radgrid_t) :: specgrid_t
      private
      real(RD) :: w_0
      real(RD) :: dw
   contains
      private
      #:for name in ('intensity', 'D_moment', 'flux')
         procedure         :: interp_${name}$_w_
         generic, public   :: interp_${name}$ => interp_${name}$_w_
      #:endfor
      procedure :: locate_w_
   end type specgrid_t

   ! Interfaces

   interface specgrid_t
      module procedure specgrid_t_
   end interface specgrid_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: specgrid_t
   public :: read
   public :: write

   ! Procedures

contains

   function specgrid_t_ (rg, w_0, dw) result (sg)

      type(radgrid_t), intent(in) :: rg
      real(RD), intent(in)        :: w_0
      real(RD), intent(in)        :: dw
      type(specgrid_t)            :: sg

      ! Construct the specgrid_t

      sg%radgrid_t = rg

      sg%w_0 = w_0
      sg%dw = dw

      ! Finish

      return

   end function specgrid_t_

   !****

   #:for name, var, arg_var, arg_type in (('intensity', 'I', 'mu', 'real(RD)'), &
                                          ('D_moment', 'D', 'l', 'integer'))

      subroutine interp_${name}$_w_(self, logT, logg, ${arg_var}$, w_0, n_w, ${var}$, stat, d_dlogT, d_dlogg)

         class(specgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: logT
         real(RD), intent(in)             :: logg
         ${arg_type}$, intent(in)         :: ${arg_var}$
         real(RD), intent(in)             :: w_0
         integer, intent(in)              :: n_w
         real(RD), intent(out)            :: ${var}$(:)
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: d_dlogT
         logical, intent(in), optional    :: d_dlogg

         integer  :: k_a
         integer  :: k_b
         real(RD) :: u
         real(RD) :: ${var}$_x(n_w+1)

         ! Interpolate the ${name}$

         call self%locate_w_(w_0, k_a, u)
         k_b = k_a + n_w

         call self%interp_${name}$(logT, logg, ${arg_var}$, k_a, k_b, ${var}$_x, stat, d_dlogT, d_dlogg)
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif

         ${var}$ = (1._RD-u)*${var}$_x(1:n_w-1) + u*${var}$_x(2:n_w)

         ! Finish

      end subroutine interp_${name}$_w_

   #:endfor

   !****

   #:for name, var in (('flux', 'F'), )

      subroutine interp_${name}$_w_(self, logT, logg, w_0, n_w, ${var}$, stat, d_dlogT, d_dlogg)

         class(specgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: logT
         real(RD), intent(in)             :: logg
         real(RD), intent(in)             :: w_0
         integer, intent(in)              :: n_w
         real(RD), intent(out)            :: ${var}$(:)
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: d_dlogT
         logical, intent(in), optional    :: d_dlogg

         integer  :: k_a
         integer  :: k_b
         real(RD) :: u
         real(RD) :: ${var}$_x(n_w+1)

         ! Interpolate the ${name}$

         call self%locate_w_(w_0, k_a, u)

         k_b = k_a + n_w

         call self%interp_${name}$(logT, logg, k_a, k_b, ${var}$_x, stat, d_dlogT, d_dlogg)
         if (PRESENT(stat)) then
            if (stat /= STAT_OK) return
         endif

         ${var}$ = (1._RD-u)*${var}$_x(1:n_w-1) + u*${var}$_x(2:n_w)

      end subroutine interp_${name}$_w_

   #:endfor

   !****

   subroutine locate_w_(self, w, k, u)

      class(specgrid_t), intent(in) :: self
      real(RD), intent(in)          :: w
      integer, intent(out)          :: k
      real(RD), intent(out)         :: u

      real(RD) :: w_pri

      ! Locate k such that (k-1)*self%dw <= w < k*self%dw,
      ! where w' = w - self%w_0

      w_pri = w - self%w_0

      k = FLOOR(w_pri/self%dw) + 1

      ! Set up the associated interpolation weight

      u = w_pri/self%dw - (k-1)

      ! Finish

      return

   end subroutine locate_w_

   !****

   subroutine read_(hi, sg, process)

      type(hdf5io_t), intent(inout)       :: hi
      type(specgrid_t), intent(out)       :: sg
      procedure(process_radint), optional :: process

      type(radgrid_t) :: rg
      real(RD)        :: w_0
      real(RD)        :: dw

      ! Read the specgrid_t

      call hi%read_attr('w_0', w_0)
      call hi%read_attr('dw', dw)

      call read(hi, rg, type='specgrid_t', process=process)

      sg = specgrid_t(rg, w_0, dw)

      ! Finish

      return

   end subroutine read_

   !****

   subroutine write_(hi, sg)

      type(hdf5io_t), intent(inout) :: hi
      type(specgrid_t), intent(in ) :: sg

      call write(hi, sg%radgrid_t, type='specgrid_t')

      call hi%write_attr('w_0', sg%w_0)
      call hi%write_attr('w_0', sg%dw)

      ! Finish

      return

   end subroutine write_

end module specgrid_m
