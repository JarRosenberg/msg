! Module  : specgrid_m
! Purpose : define specgrid_t type, for representing spectral intensity
!           grids
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module specgrid_m

   ! Uses
   
   use kinds_m
   use hdf5io_m

   use grid_m
   use specint_m
   use dyn_specint_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type :: specgrid_t
      private
      class(specint_t), allocatable :: si(:,:)
      type(grid_t)                  :: gr
      integer                       :: n_logT
      integer                       :: n_logg
   contains
      private
      procedure, public :: inquire
      #:for name in ('intensity', 'D_moment', 'flux')
         procedure, public :: interp_${name}$
      #:endfor
   end type specgrid_t

   ! Interfaces

   interface specgrid_t
      module procedure specgrid_t_
   end interface specgrid_t

   interface read
      module procedure read_nobin_
      module procedure read_rebin_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: specgrid_t
   public :: read
   public :: write

   ! Procedures

contains

   function specgrid_t_ (si, gr) result (sg)

      class(specint_t), intent(in) :: si(:,:)
      type(grid_t), intent(in)     :: gr
      type(specgrid_t)             :: sg

      integer :: n_logT
      integer :: n_logg

      ! Construct the specgrid_t

      call gr%inquire(n_logT=n_logT, n_logg=n_logg)

      @:CHECK_BOUNDS(SIZE(si, 1), n_logT)
      @:CHECK_BOUNDS(SIZE(si, 2), n_logg)
 
      allocate(sg%si, SOURCE=si)

      sg%gr = gr

      sg%n_logT = n_logT
      sg%n_logg = n_logg

      ! Finish

      return

   end function specgrid_t_

   !****

   subroutine inquire(self, n_logT, n_logg)

      class(specgrid_t), intent(in)  :: self
      integer, intent(out), optional :: n_logT
      integer, intent(out), optional :: n_logg

      ! Inquire metadata

      if (PRESENT(n_logT)) n_logT = self%n_logT
      if (PRESENT(n_logg)) n_logg = self%n_logg

      ! Finish

      return

   end subroutine inquire

   !****

   #:for name, var, arg_var, arg_type in (('intensity', 'I', 'mu', 'real(RD)'), &
                                          ('D_moment', 'D', 'l', 'integer'))

      subroutine interp_${name}$(self, logT, logg, ${arg_var}$, w_0, ${var}$, stat, d_dlogT, d_dlogg)

         class(specgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: logT
         real(RD), intent(in)             :: logg
         ${arg_type}$, intent(in)         :: ${arg_var}$
         real(RD), intent(in)             :: w_0
         real(RD), intent(out)            :: ${var}$(:)
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: d_dlogT
         logical, intent(in), optional    :: d_dlogg

         ! Interpolate the ${name}$

         call self%gr%interp(proc_, logT, logg, ${var}$, stat, d_dlogT, d_dlogg)

         ! Finish

      contains

         subroutine proc_(i, j, f, stat)

            integer, intent(in)            :: i
            integer, intent(in)            :: j
            real(RD), intent(out)          :: f(:)
            integer, intent(out), optional :: stat

            call self%si(i,j)%interp_${name}$(${arg_var}$, w_0, f, stat)

            return

         end subroutine proc_

      end subroutine interp_${name}$

   #:endfor

   !****

   #:for name, var in (('flux', 'F'), )

      subroutine interp_${name}$(self, logT, logg, w_0, ${var}$, stat, d_dlogT, d_dlogg)

         class(specgrid_t), intent(inout) :: self
         real(RD), intent(in)             :: logT
         real(RD), intent(in)             :: logg
         real(RD), intent(in)             :: w_0
         real(RD), intent(out)            :: ${var}$(:)
         integer, intent(out), optional   :: stat
         logical, intent(in), optional    :: d_dlogT
         logical, intent(in), optional    :: d_dlogg

         ! Interpolate the ${name}$

         call self%gr%interp(proc_, logT, logg, ${var}$, stat, d_dlogT, d_dlogg)

         ! Finish

      contains

         subroutine proc_(i, j, f, stat)

            integer, intent(in)            :: i
            integer, intent(in)            :: j
            real(RD), intent(out)          :: f(:)
            integer, intent(out), optional :: stat

            call self%si(i,j)%interp_${name}$(w_0, f, stat)

            return

         end subroutine proc_

      end subroutine interp_${name}$

   #:endfor

   !****

   subroutine read_nobin_(hi, sg)

      type(hdf5io_t), intent(inout) :: hi
      type(specgrid_t), intent(out) :: sg

      type(grid_t)                     :: gr
      integer                          :: n_logT
      integer                          :: n_logg
      type(dyn_specint_t), allocatable :: si(:,:)

      ! Read the specgrid_t with no rebinning

      call read_base_(hi, gr, n_logT, n_logg)

      allocate(si(n_logT,n_logg))

      call gr%map(read_specint_nobin_)

      sg = specgrid_t(si, gr)

      ! Finish

      return

   contains

      subroutine read_specint_nobin_(i, j, stat)

         integer, intent(in)            :: i
         integer, intent(in)            :: j
         integer, intent(out), optional :: stat

         type(hdf5io_t) :: hi_si

         ! Read the specint_t for the node with no rebinning
 
         hi_si = hdf5io_t(hi, si_name_(i,j))
         call read(hi_si, si(i,j))
         call hi_si%final()

         ! Finish

         return

      end subroutine read_specint_nobin_
            
   end subroutine read_nobin_

   !****

   subroutine read_rebin_(hi, sg, w_0, dw, n_w)

      type(hdf5io_t), intent(inout) :: hi
      type(specgrid_t), intent(out) :: sg
      real(RD), intent(in)          :: w_0
      real(RD), intent(in)          :: dw
      integer, intent(in)           :: n_w

      type(grid_t)                     :: gr
      integer                          :: n_logT
      integer                          :: n_logg
      type(dyn_specint_t), allocatable :: si(:,:)

      ! Read the specgrid_t with rebinning

      call read_base_(hi, gr, n_logT, n_logg)

      allocate(si(n_logT,n_logg))

      call gr%map(read_specint_rebin_)

      sg = specgrid_t(si, gr)

      ! Finish

      return

   contains
      
      subroutine read_specint_rebin_(i, j, stat)

         integer, intent(in)            :: i
         integer, intent(in)            :: j
         integer, intent(out), optional :: stat

         type(hdf5io_t) :: hi_si

         ! Read and rebin the specint_t for the node
 
         hi_si = hdf5io_t(hi, si_name_(i,j))
         call read(hi_si, si(i,j), w_0, dw, n_w)
         call hi_si%final()

         ! Finish

         return

      end subroutine read_specint_rebin_

   end subroutine read_rebin_

   !****

   subroutine read_base_(hi, gr, n_logT, n_logg)

      type(hdf5io_t), intent(inout) :: hi
      type(grid_t), intent(out)     :: gr
      integer, intent(out)          :: n_logT
      integer, intent(out)          :: n_logg
 
      character(TYPE_LEN) :: file_type
      type(hdf5io_t)      :: hi_gr
      
      ! Read base components of the specgrid_t

      call hi%read_attr('TYPE', file_type)
      @:ASSERT(file_type == 'specgrid_t', invalid type)
      
      call hi%read_attr('n_logT', n_logT)
      call hi%read_attr('n_logg', n_logg) 

      hi_gr = hdf5io_t(hi, 'gr')
      call read(hi_gr, gr)
      call hi_gr%final()

      ! Finish

      return

   end subroutine read_base_

   !****

   subroutine write_(hi, sg)

      type(hdf5io_t), intent(inout) :: hi
      type(specgrid_t), intent(in)  :: sg

      type(hdf5io_t) :: hi_gr

      ! Write the specgrid_t

      select type (si => sg%si)

      type is (specint_t)

         call hi%write_attr('TYPE', 'specgrid_t')

         call hi%write_attr('n_logT', sg%n_logT)
         call hi%write_attr('n_logg', sg%n_logg)

         hi_gr = hdf5io_t(hi, 'gr')
         call write(hi_gr, sg%gr)
         call hi_gr%final()

         call sg%gr%map(write_specint_)

      type is (dyn_specint_t)

         @:ABORT(cannot write dyn_specint_t)

      end select

      ! Finish

      return

   contains

      subroutine write_specint_(i, j, stat)

         integer, intent(in)            :: i
         integer, intent(in)            :: j
         integer, intent(out), optional :: stat

         type(hdf5io_t) :: hi_si

         ! Write the specint_t for the node
 
         hi_si = hdf5io_t(hi, si_name_(i,j))
         call write(hi_si, sg%si(i,j))
         call hi_si%final()

         ! Finish

         return

      end subroutine write_specint_

   end subroutine write_

   !****

   function si_name_(i,j) result (name)

      integer, intent(in) :: i
      integer, intent(in) :: j
      character(256)      :: name

      write(name, 100) i, j
100   format('si(',I0,',',I0,')')

   end function si_name_

end module specgrid_m
