! Module   : make_specgrid
! Purpose  : create specgrid files from specint files
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

program make_specgrid

   ! Uses

   use forum_m
   use msg_m

   use dyn_specint_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Variables

   integer                   :: n_node
   character(:), allocatable :: specgrid_filename

   type(dyn_specint_t), allocatable :: si(:)
   type(ngrid_t)                    :: ng
   type(specgrid_t)                 :: sg
   type(hdf5io_t)                   :: hi

   ! Read command-line arguments

   @:ASSERT(n_arg() >= 2, 'Syntax: make_specgrid specint_filename [specint_filename...] specgrid_filename')

   n_node = n_arg()-1
   call get_arg(n_node+1, specgrid_filename)

   ! Read the specint_t grid

   call read_specint_grid(n_node, si, ng)

   ! Create the specgrid_t

   sg = specgrid_t(si, ng)

   ! Write it

   hi = hdf5io_t(specgrid_filename, CREATE_FILE)
   call write(hi, sg)
   call hi%final()

   ! Finish

contains

   subroutine read_specint_grid(n_node, si, ng)

      integer, intent(in)                           :: n_node
      type(dyn_specint_t), allocatable, intent(out) :: si(:)
      type(ngrid_t), intent(out)                    :: ng

      character(:), allocatable         :: node_filename
      integer                           :: n
      type(hdf5io_t)                    :: hi
      type(hdf5io_t)                    :: hi_la
      character(LABEL_LEN), allocatable :: labels(:)
      character(LABEL_LEN), allocatable :: labels_chk(:)
      integer                           :: rank
      real(RD), allocatable             :: node_x(:,:)
      integer                           :: j
      type(axis_t), allocatable         :: ax(:)
      integer, allocatable              :: shape(:)
      integer, allocatable              :: k(:)
      integer                           :: n_li
      logical, allocatable              :: mask(:)
      integer, allocatable              :: vi(:)
      integer                           :: i
      real(RD)                          :: x
      integer                           :: li

      ! Do a first sweep through the files to determine labels & axis
      ! data
      
      read_axis_loop : do n = 1, n_node

         call get_arg(n, node_filename)

         hi = hdf5io_t(node_filename, OPEN_FILE_RO)
         hi_la = hdf5io_t(hi, 'labels')

         if (n == 1) then

            labels = hi_la%dset_names()

            labels = labels(sort_indices(labels))

            rank = SIZE(labels)

            allocate(node_x(rank,n_node))

         else

            labels_chk = hi_la%dset_names()
            labels_chk = labels_chk(sort_indices(labels_chk))

            @:ASSERT(SIZE(labels_chk) == rank, 'mismatched labels')
            @:ASSERT(ALL(labels_chk == labels), 'mismatched labels')

         endif

         do j = 1, rank
            call hi_la%read_dset(labels(j), node_x(j,n))
         end do

         call hi_la%final()
         call hi%final()

      end do read_axis_loop

      ! Set up the axes

      allocate(ax(rank))
      allocate(shape(rank))

      do j = 1, rank
         k = unique_indices(node_x(j,:))
         ax(j) = axis_t(node_x(j,k), labels(j))
         shape(j) = SIZE(k)
      end do

      ! Allocate arrays for data

      n_li = PRODUCT(shape)

      allocate(si(n_li))
      allocate(mask(n_li))

      ! Create the grid with a dummy mask, to provide indexing

      mask = .FALSE.

      ng = ngrid_t(ax, mask)

      ! Read in the specint_t's

      allocate(vi(rank))

      read_specint_loop : do n = 1, n_node

         do j = 1, rank

            do i = 1, shape(j)
               call ax(j)%get_x(i, x)
               if (node_x(j,n) == x) exit
            end do
            
            @:ASSERT(i <= shape(j), 'unable to locate node in grid')

            vi(j) = i

         end do

         li = ng%li_from_vi(vi)

         call get_arg(n, node_filename)

         hi = hdf5io_t(node_filename, OPEN_FILE_RO)
         call read(hi, si(li))
         call hi%final()

         mask(li) = .TRUE.

      end do read_specint_loop

      ! Re-create the grid with the correct mask, and with degenerate
      ! (length-1) dimensions stripped out

      ng = ngrid_t(PACK(ax, shape > 1), mask)

      ! Finish

   end subroutine read_specint_grid

end program make_specgrid
