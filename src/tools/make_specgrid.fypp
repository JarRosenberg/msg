! Module   : make_specgrid
! Purpose  : create specgrid files from specint files
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

program make_specgrid

   ! Uses

   use forum_m
   use msg_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Parameters

   integer, parameter :: NAME_LEN = 1024

   ! Derived-type definitions

   type node_t
      character(NAME_LEN)   :: file_name
      real(RD), allocatable :: vx(:)
      integer, allocatable  :: vi(:)
      real(RD)              :: lam_min
      real(RD)              :: lam_max
      integer               :: li
      integer               :: ci
   end type node_t

   ! Variables

   character(:), allocatable :: manifest_file_name
   character(:), allocatable :: specgrid_file_name
   logical                   :: allow_dupes

   type(specgrid_t) :: sg
   type(hdf5io_t)   :: hi
   
   ! Read command-line arguments

   @:ASSERT(n_arg() == 2 .OR. n_arg() == 3, 'Syntax: make_specgrid manifest_file_name specgrid_file_name [allow_dupes]')

   call get_arg(1, manifest_file_name)
   call get_arg(2, specgrid_file_name)

   if (n_arg() == 3) then
      call get_arg(3, allow_dupes)
   else
      allow_dupes = .FALSE.
   end if

   ! Create the grid

   call create_grid(manifest_file_name, allow_dupes, sg)

   ! Write the grid

   hi = hdf5io_t(specgrid_file_name, CREATE_FILE)
   call write(hi, sg)
   call hi%final()

   ! Finish

contains

   subroutine create_grid(manifest_file_name, allow_dupes, sg)

      character(*), intent(in)      :: manifest_file_name
      logical, intent(in)           :: allow_dupes
      type(specgrid_t), intent(out) :: sg

      type(node_t), allocatable :: nd(:)
      type(axis_t), allocatable :: ax(:)
      logical, allocatable      :: mask(:)

      ! Create the grid

      call read_nodes_axes(manifest_file_name, nd, ax)

      call build_mask(nd, ax, mask)

      call build_grid(nd, ax, mask, allow_dupes, sg)

      ! Finish

      return

   end subroutine create_grid

   !****

   subroutine read_nodes_axes(manifest_file_name, nd, ax)

      character(*), intent(in)               :: manifest_file_name
      type(node_t), allocatable, intent(out) :: nd(:)
      type(axis_t), allocatable, intent(out) :: ax(:)

      integer                   :: unit
      integer                   :: n_nd
      integer                   :: i
      type(hdf5io_t)            :: hi
      type(hdf5io_t)            :: hi_la
      character(:), allocatable :: labels(:)
      character(:), allocatable :: labels_chk(:)
      integer                   :: rank
      integer                   :: j
      real(RD), allocatable     :: x(:)
      type(tab_range_t)         :: ra

      ! Open the manifest file & count nodes (lines)

      open(NEWUNIT=unit, STATUS='OLD', FILE=manifest_file_name)

      n_nd = 0

      count_loop: do
         read(unit, *, END=100)
         n_nd = n_nd + 1
      end do count_loop
      
100   continue

      ! Read the node data

      rewind(unit)

      allocate(nd(n_nd))

      node_loop : do i = 1, n_nd

         read(unit, 110) nd(i)%file_name
110      format(A)

         ! Open the HDF5 file

         hi = hdf5io_t(nd(i)%file_name, OPEN_FILE_RO)

         ! Read axis labels/values

         hi_la = hdf5io_t(hi, 'labels')

         if (i == 1) then

            labels = hi_la%dset_names()

            associate (s => sort_indices(labels))
              labels = labels(s)
            end associate

            rank = SIZE(labels)

         else

            labels_chk = hi_la%dset_names()

            associate (s => sort_indices(labels_chk))
              labels_chk = labels_chk(s)
            end associate

            @:ASSERT(SIZE(labels_chk) == rank, 'mismatched labels')
            @:ASSERT(ALL(labels_chk == labels), 'mismatched labels')

         endif

         allocate(nd(i)%vx(rank))

         do j = 1, rank
            call hi_la%read_dset(labels(j), nd(i)%vx(j))
         end do

         call hi_la%final()

         ! Read wavelength range

         call hi%read_attr('lam_min', nd(i)%lam_min)
         call hi%read_attr('lam_max', nd(i)%lam_max)

         ! Close the file
         
         call hi%final()

      end do node_loop

      close(unit)

      ! Set up the axes

      allocate(x(n_nd))
      allocate(ax(rank))

      do j = 1, rank

         do i = 1, n_nd
            x(i) = nd(i)%vx(j)
         end do
         
         associate (u => unique_indices(x))
           ra = tab_range_t(x(u))
         end associate

         ax(j) = axis_t(ra, labels(j))

      end do

      ! Finish

      return

   end subroutine read_nodes_axes

   !****

   subroutine build_mask(nd, ax, mask)

      type(node_t), intent(in)          :: nd(:)
      type(axis_t), intent(in)          :: ax(:)
      logical, allocatable, intent(out) :: mask(:)

      integer              :: rank
      integer, allocatable :: shape(:)
      integer              :: j
      integer              :: n_li
      type(ngrid_t)        :: ng
      integer              :: i
      integer              :: vi(SIZE(ax))
      integer              :: li

      ! Initialize the mask

      rank = SIZE(ax)
      allocate(shape(rank))
     
      do j = 1, rank
         call ax(j)%inquire(n=shape(j))
      end do

      n_li = PRODUCT(shape)

      allocate(mask(n_li))
      mask = .FALSE.

      ! Create a dummy ngrid_t to provide indexing      

      ng = ngrid_t(ax, mask)

      ! Update the mask

      do i = 1, SIZE(nd)

         call ng%locate(nd(i)%vx, vi)
         li = ng%li_from_vi(vi)

         mask(li) = .TRUE.

      end do

      ! Finish

      return

   end subroutine build_mask

   !****

   subroutine build_grid(nd, ax, mask, allow_dupes, sg)

      type(node_t), intent(in)      :: nd(:)
      type(axis_t), intent(in)      :: ax(:)
      logical, intent(in)           :: mask(:)
      logical, intent(in)           :: allow_dupes
      type(specgrid_t), intent(out) :: sg
 
      integer                          :: rank
      integer, allocatable             :: shape(:)
      integer                          :: j
      type(ngrid_t)                    :: ng
      integer                          :: n_ci
      character(NAME_LEN), allocatable :: file_names(:)
      character(NAME_LEN), allocatable :: group_names(:)
      integer                          :: i
      integer                          :: vi(SIZE(ax))
      integer                          :: li
      integer                          :: ci
      type(hdf5_spectable_t)           :: st
      
      ! Create the ngrid_t with degenerate (length-1) dimensions
      ! stripped out

      rank = SIZE(ax)
      allocate(shape(rank))
     
      do j = 1, rank
         call ax(j)%inquire(n=shape(j))
      end do

      ng = ngrid_t(PACK(ax, shape > 1), mask)

      ! Set up the file/group name lists (with duplicate nodes removed)

      n_ci = COUNT(mask)

      allocate(file_names(n_ci))
      file_names = ''

      do i = 1, SIZE(nd)

         call ng%locate(PACK(nd(i)%vx, shape > 1), vi)
         li = ng%li_from_vi(vi)
         ci = ng%ci_from_li(li)

         if (file_names(ci) /= '' .AND. .NOT. allow_dupes) then
            write(ERROR_UNIT, 100) TRIM(nd(i)%file_name), TRIM(file_names(ci)), nd(i)%vx
100         format('file ', A, ' replaces existing file ', A,'; axes =', 999(1X,E11.4))
            @:ABORT('set the allow_dupes flag to proceed')
         end if

         file_names(ci) = nd(i)%file_name

      end do

      allocate(group_names(n_ci))
      group_names = '/'

      ! Create the spectable_t

      st = hdf5_spectable_t(file_names, group_names, MAXVAL(nd%lam_min), MINVAL(nd%lam_max), cache_limit=0)

      ! Create the specgrid_t

      sg = specgrid_t(st, ng)

      ! Finish

      return

   end subroutine build_grid

end program make_specgrid
