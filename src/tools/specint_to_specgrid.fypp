! Module   : specint_to_specgrid
! Purpose  : Create specgrid files from specint files
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

program specint_to_specgrid

   ! Uses

   use forum_m
   use msg_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Parameters

   integer, parameter :: NAME_LEN = 1024
   logical, parameter :: VERBOSE = .FALSE.

   ! Derived-type definitions

   type smeta_t
      character(NAME_LEN)   :: file_name
      real(RD), allocatable :: x_vec(:)
      real(RD)              :: lam_min
      real(RD)              :: lam_max
   end type smeta_t

   ! Variables

   character(:), allocatable :: manifest_file_name
   character(:), allocatable :: specgrid_file_name
   character(:), allocatable :: label

   type(specgrid_t) :: specgrid
   type(hdf5io_t)   :: hdf5io
   
   ! Read command-line arguments

   @:ASSERT(n_arg() == 3, 'Syntax: specint_to_specgrid manifest_file_name specgrid_file_name label')

   call get_arg(1, manifest_file_name)
   call get_arg(2, specgrid_file_name)
   call get_arg(3, label)

   ! Create the grid

   call create_grid(manifest_file_name,  specgrid)

   ! Write the grid

   hdf5io = hdf5io_t(specgrid_file_name, CREATE_FILE)

   call specgrid%write(hdf5io)

   call hdf5io%write_attr('label', label)

   call hdf5io%final()

   ! Finish

contains

   subroutine create_grid(manifest_file_name, specgrid)

      character(*), intent(in)      :: manifest_file_name
      type(specgrid_t), intent(out) :: specgrid

      type(smeta_t), allocatable :: smetas(:)
      character(:), allocatable  :: labels(:)

      ! Create the grid

      call read_smetas(manifest_file_name, smetas, labels)

      call build_grid(smetas, labels, specgrid)

      ! Finish

      return

   end subroutine create_grid

   !****

   subroutine read_smetas(manifest_file_name, smetas, labels)

      character(*), intent(in)                :: manifest_file_name
      type(smeta_t), allocatable, intent(out) :: smetas(:)
      character(:), allocatable, intent(out)  :: labels(:)

      integer        :: unit
      integer        :: n_smetas
      integer        :: i
      type(hdf5io_t) :: hdf5io
      type(hdf5io_t) :: hdf5io_labels
      integer        :: rank
      integer        :: j

      ! Open the manifest file & count lines

      open(NEWUNIT=unit, STATUS='OLD', FILE=manifest_file_name)

      n_smetas = 0

      count_loop: do
         read(unit, *, END=100)
         n_smetas = n_smetas + 1
      end do count_loop
      
100   continue

      ! Read the spectrum metadata

      rewind(unit)

      allocate(smetas(n_smetas))

      write(OUTPUT_UNIT, 110) 'Reading spectrum metadata...'
110   format(A)

      smeta_loop : do i = 1, n_smetas

         read(unit, 110) smetas(i)%file_name

         if (VERBOSE) then
            write(OUTPUT_UNIT, 120) TRIM(smetas(i)%file_name)
120         format(2X,A)
         end if

         ! Open the HDF5 file

         hdf5io = hdf5io_t(smetas(i)%file_name, OPEN_FILE_RO)

         ! Read axis labels/values

         hdf5io_labels = hdf5io_t(hdf5io, 'labels')

         if (i == 1) then

            labels = hdf5io_labels%attr_names()

            associate (s => sort_indices(labels))
              labels = labels(s)
            end associate

            rank = SIZE(labels)

         endif

         allocate(smetas(i)%x_vec(rank))

         do j = 1, rank
            call hdf5io_labels%read_attr(labels(j), smetas(i)%x_vec(j))
         end do

         call hdf5io_labels%final()

         ! Read wavelength range

         call hdf5io%read_attr('lam_min', smetas(i)%lam_min)
         call hdf5io%read_attr('lam_max', smetas(i)%lam_max)

         ! Close the file
         
         call hdf5io%final()

      end do smeta_loop

      close(unit)

      write(OUTPUT_UNIT, 130) 'Number of spectra:', n_smetas
130   format(2X,A,1X,I0)

      ! Finish

      return

   end subroutine read_smetas

!    !****

!    subroutine build_axes(smetas, labels, axes)

!       type(smeta_t), intent(in)              :: smetas(:)
!       character(*), intent(in)               :: labels(:)
!       type(axis_t), allocatable, intent(out) :: axes(:)

!       integer                :: n_smetas
!       integer                :: rank
!       integer                :: i
!       integer                :: j
!       real(RD), allocatable  :: x(:)

!       ! Build the axes

!       write(OUTPUT_UNIT, 100) 'Building axes...'
! 100   format(A)

!       n_smetas = SIZE(smetas)
!       rank = SIZE(labels)

!       allocate(x(n_smetas))
!       allocate(axes(rank))

!       do j = 1, rank

!          do i = 1, n_smetas
!             x(i) = smetas(i)%x_vec(j)
!          end do
         
!          associate (u => unique_indices(x))

!            axes(j) = axis_t(x(u), labels(j))

!            write(OUTPUT_UNIT, 110) 'Axis', j, ':', TRIM(labels(j)), '(', MINVAL(x(u)), '->', MAXVAL(x(u)), &
!                 ',', SIZE(x(u)), 'points)'
! 110        format(2X,A,1X,I0,1X,A,1X,A,1X,A,1PE10.3,1X,A,1X,1PE10.3,1X,A,1X,I0,1X,A)

!          end associate

!       end do


!       ! Finish

!       return

!    end subroutine build_axes

!    !****

!    subroutine strip_degen(smetas, labels, axes)

!       type(smeta_t), intent(inout)             :: smetas(:)
!       character(:), allocatable, intent(inout) :: labels(:)
!       type(axis_t), allocatable, intent(inout) :: axes(:)

!       integer                   :: rank
!       integer, allocatable      :: shape(:)
!       logical, allocatable      :: mask(:)
!       integer                   :: i
!       integer                   :: j
!       character(:), allocatable :: labels_new(:)

!       ! Strip degenerate (length-1) axes

!       rank = SIZE(axes)
!       allocate(shape(rank))

!       call shape_from_axes(axes, shape)

!       mask = shape > 1

!       if (COUNT(mask) < rank) then

!          write(OUTPUT_UNIT, 100) 'Stripping degenerate axes...'
! 100      format(A)

!          do j = 1, SIZE(mask)
!             if (.NOT. mask(j)) write(OUTPUT_UNIT, 110) 'Axis', j, ':', TRIM(labels(j))
! 110         format(2X,A,1X,I0,1X,A,1X,A)
!          end do

!          do i = 1, SIZE(smetas)
!             smetas(i)%x_vec = PACK(smetas(i)%x_vec, mask)
!          end do

!          ! The following code works around a bug in gfortran, with
!          ! assignment of character arrays

!          allocate(labels_new(COUNT(mask)), MOLD=labels)

!          i = 1

!          do j = 1, SIZE(mask)
!             if (mask(j)) then
!                labels_new(i) = labels(j)
!                i = i + 1
!             end if
!          end do

!          call MOVE_ALLOC(labels_new, labels)
!          axes = PACK(axes, mask)

!          ! Re-build the axes and usage mask

!          call build_axes(smetas, labels, axes)

!       end if

!       ! Finish

!       return

!    end subroutine strip_degen

!    !****

!    subroutine build_mask(smetas, axes, mask)

!       type(smeta_t), intent(in)         :: smetas(:)
!       type(axis_t), intent(in)          :: axes(:)
!       logical, allocatable, intent(out) :: mask(:)

!       integer       :: shape(SIZE(axes))
!       integer       :: n_lin
!       type(vgrid_t) :: vgrid
!       integer       :: i
!       integer       :: i_vec(SIZE(axes))
!       integer       :: i_lin

!       ! Initialize the node occupancy mask

!       write(OUTPUT_UNIT, 100) 'Building node occupancy mask...'
! 100   format(A)

!       call shape_from_axes(axes, shape)

!       n_lin = PRODUCT(shape)

!       allocate(mask(n_lin))
!       mask = .FALSE.

!       ! Create a dummy vgrid to provide indexing      

!       vgrid = vgrid_t(axes, mask)

!       ! Update the mask

!       do i = 1, SIZE(smetas)

!          call vgrid%locate(smetas(i)%x_vec, i_vec)
!          i_lin = vgrid%lin_from_vec(i_vec)

!          mask(i_lin) = .TRUE.

!       end do

!       write(OUTPUT_UNIT, 110) 'Number of nodes (total)   :', n_lin
!       write(OUTPUT_UNIT, 110) 'Number of nodes (defined) :', SIZE(smetas)
! 110   format(2X,A,1X,I0)

!       ! Finish

!       return

!    end subroutine build_mask

!    !****

!    subroutine trim_smetas(smetas, labels, axes, mask)

!       type(smeta_t), allocatable, intent(inout) :: smetas(:)
!       character(:), allocatable, intent(inout)  :: labels(:)
!       type(axis_t), allocatable, intent(inout)  :: axes(:)
!       logical, allocatable, intent(inout)       :: mask(:)

!       logical, allocatable :: use_mask(:)
!       type(vgrid_t)        :: vgrid
!       integer              :: rank
!       integer, allocatable :: shape(:)
!       integer, allocatable :: i_cell(:)
!       integer, allocatable :: i_vec_cnr(:)
!       integer, allocatable :: i_lin_cnr(:)
!       integer              :: i_lin
!       integer              :: i_cnr
!       integer              :: j
!       logical, allocatable :: smetas_mask(:)
!       integer              :: i

!       ! Create a dummy vgrid to provide indexing

!       vgrid = vgrid_t(axes, mask)

!       ! Allocate indexing arrays

!       rank = SIZE(axes)
!       allocate(shape(rank))

!       call shape_from_axes(axes, shape)

!       allocate(i_cell(rank))
!       allocate(i_vec_cnr(rank))

!       allocate(i_lin_cnr(2**rank))

!       ! Loop through cells of the grid, setting use_mask for those
!       ! nodes that belong to "complete" cells (i.e., with all corner
!       ! nodes present)

!       allocate(use_mask(SIZE(mask)))
!       use_mask = .FALSE.

!       do i_lin = 1, SIZE(mask)

!          i_cell = vgrid%vec_from_lin(i_lin)

!          if (ALL(i_cell < shape)) then

!             ! Get a list of linear and contiguous indices for the cell
!             ! corners

!             corner_loop : do i_cnr = 1, 2**rank

!                do j = 1, rank

!                   if (BTEST(i_cnr-1, j-1)) then
!                      i_vec_cnr(j) = i_cell(j) + 1
!                   else
!                      i_vec_cnr(j) = i_cell(j)
!                   endif

!                end do

!                i_lin_cnr(i_cnr) = vgrid%lin_from_vec(i_vec_cnr)

!             end do corner_loop

!             ! See whether all corners are present

!             if (ALL(mask(i_lin_cnr))) then
!                use_mask(i_lin_cnr) = .TRUE.
!             end if

!          end if

!       end do

!       ! If necessary, perform the trimming

!       if (COUNT(use_mask) < COUNT(mask)) then

!          ! Trim the smetas list based on the usage mask

!          write(OUTPUT_UNIT, 100) 'Trimming unusable spectra...'
! 100      format(A)

!          allocate(smetas_mask(SIZE(smetas)))

!          do i = 1, SIZE(smetas)

!             call vgrid%locate(smetas(i)%x_vec, i_cell)
!             i_lin = vgrid%lin_from_vec(i_cell)

!             smetas_mask(i) = use_mask(i_lin)

!             if (VERBOSE .AND. .NOT. smetas_mask(i)) then

!                write(OUTPUT_UNIT, 110) 'Trim', i_lin, ', coords', i_cell
! 110            format(2X,A,1X,I0,A,999(1X,I0))
!                write(OUTPUT_UNIT, 115) 'from file', TRIM(smetas(i)%file_name), smetas(i)%x_vec
! 115            format(A,1X,A,999(1X,1PE10.3))
!             end if

!          end do

!          write(OUTPUT_UNIT, 120) 'Number of spectra (usable)   :', COUNT(smetas_mask)
!          write(OUTPUT_UNIT, 120) 'Number of spectra (unusable) :', SIZE(smetas_mask)-COUNT(smetas_mask)
! 120      format(2X,A,1X,I0)

!          smetas = PACK(smetas, smetas_mask)

!          ! Re-build the axes and usage mask

!          call build_axes(smetas, labels, axes)
!          call build_mask(smetas, axes, mask)

!       end if

!       ! Finish

!       return

!    end subroutine trim_smetas

   !****

   subroutine build_grid(smetas, labels, specgrid)

      type(smeta_t), allocatable, intent(inout) :: smetas(:)
      character(*), intent(in)                  :: labels(:)
      type(specgrid_t), intent(out)             :: specgrid

      integer                          :: n_smetas
      integer                          :: rank
      real(RD), allocatable            :: x_vecs(:,:)
      logical, allocatable             :: mask(:)
      integer                          :: i
      type(vgrid_t)                    :: vgrid
      character(NAME_LEN), allocatable :: file_names(:)
      character(NAME_LEN), allocatable :: group_names(:)
      type(hdf5_specsource_t)          :: specsource
      
      ! Create the vgrid

      write(OUTPUT_UNIT, 100) 'Building grid...'
100   format(A)

      ! First, get the list of vertex coordinates

      n_smetas = SIZE(smetas)
      rank = SIZE(labels)

      allocate(x_vecs(rank,n_smetas))

      do i = 1, n_smetas
         x_vecs(:,i) = smetas(i)%x_vec
      enddo

      ! Optimize it

      allocate(mask(n_smetas))

      call optimize(x_vecs, mask)

      smetas = PACK(smetas, mask)

      n_smetas = SIZE(smetas)

      deallocate(x_vecs)
      allocate(x_vecs(rank,n_smetas))

      do i = 1, n_smetas
         x_vecs(:,i) = smetas(i)%x_vec
      enddo

      ! Construct the grid

      vgrid = vgrid_t(x_vecs, labels)

      ! Set up the file/group name lists

      file_names = smetas%file_name

      allocate(group_names(n_smetas))
      group_names = '/'

      ! Create specsource

      specsource = hdf5_specsource_t(file_names, group_names, MAXVAL(smetas%lam_min), MINVAL(smetas%lam_max))

      ! Create specgrid

      specgrid = specgrid_t(specsource, vgrid)

      call specgrid%set_cache_limit(0)

      ! Finish

      return

   end subroutine build_grid

   ! !****

   ! subroutine shape_from_axes(axes, shape)

   !    type(axis_t), intent(in) :: axes(:)
   !    integer, intent(out)     :: shape(:)

   !    integer :: j

   !    ! Get the shape from the axes

   !    do j = 1, SIZE(axes)
   !       call axes(j)%get_n(shape(j))
   !    end do

   !    ! Finish

   !    return

   ! end subroutine shape_from_axes

end program specint_to_specgrid
