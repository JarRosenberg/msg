#:include 'forum.inc'

module test_math_m

   ! Uses
   
   use kinds_m
   use math_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Access specifiers

   private

   public :: test


contains

   subroutine test()

      call test_integrate_con_()
      call test_integrate_lin_()

   end subroutine test

   !****

   subroutine test_integrate_con_()

      real(R8), allocatable :: x(:)
      real(R8), allocatable :: y(:)
      real(R8)              :: x_a
      real(R8)              :: x_b
      real(R8)              :: iy
      real(R8)              :: iy_chk

      integer :: i

      ! Iterate over test instances

      print *,'integrate_con'

      do i = 1, 3
         call integrate_con_arrange_(i)
         call integrate_con_act_(i)
         call integrate_con_assert_(i)
      end do

      ! Finish

      return

   contains

      subroutine integrate_con_arrange_(i)

         integer, intent(in) :: i

         integer :: k

         x = [(k,k=1,10)]
         y = [(1._R8,k=1,9)]

         select case (i)
         case (1)
            x_a = 3.15_R8
            x_b = 3.45_R8
            iy_chk = 0.30_R8
         case (2)
            x_a = 3.15_R8
            x_b = 6.25_R8
            iy_chk = 3.10_R8
         case (3)
            x_a = 1._R8
            x_b = 10._R8
            iy_chk = 9._R8
         case default
            @:ABORT(invalid instance)
         end select

         ! Finish

         return

      end subroutine integrate_con_arrange_

      !****

      subroutine integrate_con_act_(i)

         integer, intent(in) :: i

         iy = integrate_con(x, y, x_a, x_b)

         ! Finish

         return

      end subroutine integrate_con_act_

      !****

      subroutine integrate_con_assert_(i)

         integer, intent(in) :: i

         real(R8) :: err

         err = ABS((iy - iy_chk)/iy_chk)

         if (err < 1E-13) then
            print *, '  PASS', i
         else
            print *, '  FAIL', i, err
         end if

         ! Finish

         return

      end subroutine integrate_con_assert_

   end subroutine test_integrate_con_
   

   !****

   subroutine test_integrate_lin_()

      real(R8), allocatable :: x(:)
      real(R8), allocatable :: y(:)
      real(R8)              :: x_a
      real(R8)              :: x_b
      real(R8)              :: iy
      real(R8)              :: iy_chk

      integer :: i

      ! Iterate over test instances

      print *,'integrate_lin'

      do i = 1, 3
         call integrate_lin_arrange_(i)
         call integrate_lin_act_(i)
         call integrate_lin_assert_(i)
      end do

      ! Finish

      return

   contains

      subroutine integrate_lin_arrange_(i)

         integer, intent(in) :: i

         integer :: k

         x = [(k,k=1,10)]
         y = x**2

         select case (i)
         case (1)
            x_a = 3.15_R8
            x_b = 3.45_R8
            iy_chk = 3.33_R8
         case (2)
            x_a = 3.15_R8
            x_b = 6.25_R8
            iy_chk = 71.4775_R8
         case (3)
            x_a = 1._R8
            x_b = 10._R8
            iy_chk = 334.5_R8
         case default
            @:ABORT(invalid instance)
         end select

         ! Finish

         return

      end subroutine integrate_lin_arrange_

      !****

      subroutine integrate_lin_act_(i)

         integer, intent(in) :: i

         iy = integrate_lin(x, y, x_a, x_b)

         ! Finish

         return

      end subroutine integrate_lin_act_

      !****

      subroutine integrate_lin_assert_(i)

         integer, intent(in) :: i

         real(R8) :: err

         err = ABS((iy - iy_chk)/iy_chk)

         if (err < 1E-13) then
            print *, '  PASS', i
         else
            print *, '  FAIL', i, err
         end if

         ! Finish

         return

      end subroutine integrate_lin_assert_

   end subroutine test_integrate_lin_

end module test_math_m
