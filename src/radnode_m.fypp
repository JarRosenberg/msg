! Module  : radnode_m
! Purpose : define radnode_t type, for representing radiant intensity
!           grid nodes
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module radnode_m

   ! Uses
   
   use kinds_m
   use hdf5io_m

   use radint_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type radnode_t
      private
      type(radint_t) :: ri
      type(radint_t) :: dri_dlnT
      type(radint_t) :: dri_dlng
      type(radint_t) :: d2ri_dlnTdlng
   contains
      private
      procedure, public :: intensity
      procedure, public :: flux
   end type radnode_t

   ! Interfaces

   interface radnode_t
      module procedure radnode_t_
   end interface radnode_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: radnode_t
   public :: read
   public :: write

   ! Procedures

contains

   function radnode_t_ (ri, dri_dlnT, dri_dlng, d2ri_dlnTdlng) result (rn)

      type(radint_t), intent(in) :: ri
      type(radint_t), intent(in) :: dri_dlnT
      type(radint_t), intent(in) :: dri_dlng
      type(radint_t), intent(in) :: d2ri_dlnTdlng
      type(radnode_t)            :: rn

      ! Costruct the radnode_t

      rn%ri = ri
      rn%dri_dlnT = dri_dlnT
      rn%dri_dlng = dri_dlng
      rn%d2ri_dlnTdlng = d2ri_dlnTdlng

      ! Finish

      return

   end function radnode_t_

   !****

   function intensity (self, mu, d_dlnT, d_dlng) result (I)

      class(radnode_t), intent(in), target :: self
      real(RD), intent(in)                :: mu
      logical, intent(in), optional       :: d_dlnT
      logical, intent(in), optional       :: d_dlng
      real(RD)                            :: I

      logical                 :: d_dlnT_
      logical                 :: d_dlng_
      type(radint_t), pointer :: ri

      if (PRESENT(d_dlnT)) then
         d_dlnT_ = d_dlnT
      else
         d_dlnT_ = .FALSE.
      endif

      if (PRESENT(d_dlng)) then
         d_dlng_ = d_dlng
      else
         d_dlng_ = .FALSE.
      endif

      ! Evaluate the intensity or its derivative

      if (d_dlnT_) then
         if (d_dlng_) then
            ri => self%d2ri_dlnTdlng
         else
            ri => self%dri_dlnT
         endif
      else
         if (d_dlng_) then
            ri => self%dri_dlng
         else
            ri => self%ri
         endif
      endif

      I = ri%intensity(mu)

      ! Finish

      return

   end function intensity

   !****

   function flux (self, d_dlnT, d_dlng) result (F)

      class(radnode_t), intent(in), target :: self
      logical, intent(in), optional        :: d_dlnT
      logical, intent(in), optional        :: d_dlng
      real(RD)                             :: F

      logical                 :: d_dlnT_
      logical                 :: d_dlng_
      type(radint_t), pointer :: ri

      if (PRESENT(d_dlnT)) then
         d_dlnT_ = d_dlnT
      else
         d_dlnT_ = .FALSE.
      endif

      if (PRESENT(d_dlng)) then
         d_dlng_ = d_dlng
      else
         d_dlng_ = .FALSE.
      endif

      ! Evaluate the flux or its derivative

      if (d_dlnT_) then
         if (d_dlng_) then
            ri => self%d2ri_dlnTdlng
         else
            ri => self%dri_dlnT
         endif
      else
         if (d_dlng_) then
            ri => self%dri_dlng
         else
            ri => self%ri
         endif
      endif

      F = ri%flux()

      ! Finish

      return

   end function flux

   !****

   subroutine read_(hi, rn)

      type(hdf5io_t), intent(inout) :: hi
      type(radnode_t), intent(out)  :: rn

      character(TYPE_LEN) :: type
      type(hdf5io_t)      :: hi_ri
      type(radint_t)      :: ri
      type(radint_t)      :: dri_dlnT
      type(radint_t)      :: dri_dlng
      type(radint_t)      :: d2ri_dlnTdlng

      ! Read the radnode_t

      call hi%read_attr('TYPE', type)
      @:ASSERT(type == 'radnode_t',invalid type)

      hi_ri = hdf5io_t(hi, 'ri')
      call read(hi_ri, ri)
      call hi_ri%final()

      hi_ri = hdf5io_t(hi, 'dri_dlnT')
      call read(hi_ri, dri_dlnT)
      call hi_ri%final()

      hi_ri = hdf5io_t(hi, 'dri_dlng')
      call read(hi_ri, dri_dlng)
      call hi_ri%final()

      hi_ri = hdf5io_t(hi, 'd2ri_dlnTdlng')
      call read(hi_ri, d2ri_dlnTdlng)
      call hi_ri%final()

      rn = radnode_t(ri, dri_dlnT, dri_dlng, d2ri_dlnTdlng)

      ! Finish

      return

   end subroutine read_

   !****

   subroutine write_(hi, rn)

      type(hdf5io_t), intent(inout) :: hi
      type(radnode_t), intent(in)   :: rn

      type(hdf5io_t) :: hi_ri

      ! Write the radnode_t

      call hi%write_attr('TYPE', 'radnode_t')

      hi_ri = hdf5io_t(hi, 'ri')
      call write(hi_ri, rn%ri)
      call hi_ri%final()

      hi_ri = hdf5io_t(hi, 'dri_dlnT')
      call write(hi_ri, rn%dri_dlnT)
      call hi_ri%final()

      hi_ri = hdf5io_t(hi, 'dri_dlng')
      call write(hi_ri, rn%dri_dlng)
      call hi_ri%final()

      hi_ri = hdf5io_t(hi, 'd2ri_dlnTdlng')
      call write(hi_ri, rn%d2ri_dlnTdlng)
      call hi_ri%final()

      ! Finish

      return

   end subroutine write_

end module radnode_m
