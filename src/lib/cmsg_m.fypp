! Module  : cmsg_m
! Purpose : C public interface for MSG modules
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module cmsg_m

   ! Uses

   use forum_m
   use msg_m

   use ISO_FORTRAN_ENV
   use ISO_C_BINDING

   ! No implicit typing

   implicit none

   ! Access specifiers

   private

   #:for name in ('specgrid', 'photgrid')
      public :: load_${name}$
      public :: unload_${name}$
      public :: inquire_${name}$
      public :: interp_intensity_${name}$
      public :: interp_E_moment_${name}$
      public :: interp_D_moment_${name}$
      public :: interp_flux_${name}$
   #:endfor
   public :: load_photgrid_from_specgrid

   public :: STAT_OK
   public :: STAT_OUT_OF_BOUNDS_AXIS_LO
   public :: STAT_OUT_OF_BOUNDS_AXIS_HI
   public :: STAT_OUT_OF_BOUNDS_LAM_LO
   public :: STAT_OUT_OF_BOUNDS_LAM_HI
   public :: STAT_OUT_OF_BOUNDS_MU_LO
   public :: STAT_OUT_OF_BOUNDS_MU_HI
   public :: STAT_UNAVAILABLE_DATA
   public :: STAT_INVALID_ARGUMENT
   public :: STAT_INVALID_TYPE
   public :: STAT_FILE_NOT_FOUND

   ! Procedures

contains

   subroutine load_specgrid(specgrid_file_name, specgrid_ptr, stat, cache_limit) bind(C, name='load_SpecGrid')

      character(C_CHAR)        :: specgrid_file_name(*)
      type(C_PTR)              :: specgrid_ptr
      integer(C_INT), optional :: stat
      integer(C_INT), optional :: cache_limit

      type(hdf5io_t)            :: hdf5io
      type(specgrid_t), pointer :: specgrid

      ! Load the specgrid from file
      
      call open_file_(specgrid_file_name, hdf5io, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      endif

      allocate(specgrid)

      call read(hdf5io, specgrid, stat, cache_limit)
      if (STAT /= STAT_OK) then
         deallocate(specgrid)
         return
      endif

      call hdf5io%final()

      ! Set up the C pointer

      specgrid_ptr = C_LOC(specgrid)

      ! Finish

      return

   end subroutine load_specgrid

   !****

   subroutine load_photgrid(photgrid_file_name, photgrid_ptr, stat) bind(C, name='load_PhotGrid')

      character(C_CHAR)        :: photgrid_file_name(*)
      type(C_PTR)              :: photgrid_ptr
      integer(C_INT), optional :: stat

      type(hdf5io_t)            :: hdf5io
      type(photgrid_t), pointer :: photgrid

      ! Load the photgrid from file
      
      call open_file_(photgrid_file_name, hdf5io, stat)
      if (PRESENT(stat)) then
         if (stat /= STAT_OK) return
      endif

      allocate(photgrid)

      call read(hdf5io, photgrid, stat)
      if (STAT /= STAT_OK) then
         deallocate(photgrid)
         return
      endif

      call hdf5io%final()

      ! Set up the C pointer

      photgrid_ptr = C_LOC(photgrid)

      ! Finish

      return

   end subroutine load_photgrid

   !****

   subroutine load_photgrid_from_specgrid(specgrid_file_name, passband_file_name, &
                                          photgrid_ptr, stat) bind(C, name='load_PhotGrid_from_SpecGrid')

      character(C_CHAR)        :: specgrid_file_name(*)
      character(C_CHAR)        :: passband_file_name(*)
      type(C_PTR)              :: photgrid_ptr
      integer(C_INT), optional :: stat

      type(hdf5io_t)            :: hdf5io
      type(passband_t)          :: passband
      type(photgrid_t), pointer :: photgrid

      ! Load the photgrid from specgrid and passband files

      call open_file_(passband_file_name, hdf5io, stat)
      if (stat /= STAT_OK) return
      
      call read(hdf5io, passband, stat)
      if (stat /= STAT_OK) return

      call hdf5io%final()

      call open_file_(specgrid_file_name, hdf5io, stat)
      if (stat /= STAT_OK) return

      allocate(photgrid)

      call read(hdf5io, passband, photgrid, stat)
      if (stat /= STAT_OK) then
         deallocate(photgrid)
         return
      endif

      call hdf5io%final()

      ! Set up the C pointer

      photgrid_ptr = C_LOC(photgrid)

      ! Finish

      return
      
   end subroutine load_photgrid_from_specgrid

   !****

   subroutine unload_specgrid(specgrid_ptr) bind(C, name='unload_SpecGrid')

      type(C_PTR), value :: specgrid_ptr

      type(specgrid_t), pointer :: specgrid

      ! Set up the Fortran pointer

      call C_F_POINTER(specgrid_ptr, specgrid)

      ! Deallocate the grid

      if (ASSOCIATED(specgrid)) deallocate(specgrid)

      ! Finish

      return

   end subroutine unload_specgrid

   !****

   subroutine unload_photgrid(photgrid_ptr) bind(C, name='unload_PhotGrid')

      type(C_PTR), value :: photgrid_ptr

      type(photgrid_t), pointer :: photgrid

      ! Set up the Fortran pointer

      call C_F_POINTER(photgrid_ptr, photgrid)

      ! Deallocate the grid

      if (ASSOCIATED(photgrid)) deallocate(photgrid)

      ! Finish

      return

   end subroutine unload_photgrid

   !****

   subroutine inquire_specgrid(specgrid_ptr, lam_min, lam_max, shape_ptr, rank, &
                               axis_min_ptr, axis_max_ptr) bind(C, name='inquire_SpecGrid')

      type(C_PTR), value :: specgrid_ptr
      real(C_DOUBLE)     :: lam_min
      real(C_DOUBLE)     :: lam_max
      type(C_PTR), value :: shape_ptr
      integer(C_INT)     :: rank
      type(C_PTR), value :: axis_min_ptr
      type(C_PTR), value :: axis_max_ptr

      type(specgrid_t), pointer :: specgrid
      integer                   :: rank_
      integer, pointer          :: shape(:)
      real(RD), pointer         :: axis_min(:)
      real(RD), pointer         :: axis_max(:)

      ! Set up the Fortran pointer

      call C_F_POINTER(specgrid_ptr, specgrid)

      ! Inquire metadata

      if (C_ASSOCIATED(shape_ptr)) then
         call specgrid%inquire(rank=rank_)
         call C_F_POINTER(shape_ptr, shape, [rank_])
         call specgrid%inquire(shape=shape)
      endif

      if (C_ASSOCIATED(axis_min_ptr)) then
         call specgrid%inquire(rank=rank_)
         call C_F_POINTER(axis_min_ptr, axis_min, [rank_])
         call specgrid%inquire(axis_min=axis_min)
      endif

      if (C_ASSOCIATED(axis_max_ptr)) then
         call specgrid%inquire(rank=rank_)
         call C_F_POINTER(axis_max_ptr, axis_max, [rank_])
         call specgrid%inquire(axis_max=axis_max)
      endif

      call specgrid%inquire(lam_min=lam_min, lam_max=lam_max, rank=rank)

      ! Finish

      return

   end subroutine inquire_specgrid

   !****

   subroutine inquire_photgrid(photgrid_ptr, shape_ptr, rank, &
                               axis_min_ptr, axis_max_ptr) bind(C, name='inquire_PhotGrid')

      type(C_PTR), value :: photgrid_ptr
      type(C_PTR), value :: shape_ptr
      integer(C_INT)     :: rank
      type(C_PTR), value :: axis_min_ptr
      type(C_PTR), value :: axis_max_ptr
      
      type(photgrid_t), pointer :: photgrid
      integer                   :: rank_
      integer, pointer          :: shape(:)
      real(RD), pointer         :: axis_min(:)
      real(RD), pointer         :: axis_max(:)

      ! Set up the Fortran pointer

      call C_F_POINTER(photgrid_ptr, photgrid)

      ! Inquire metadata

      if (C_ASSOCIATED(shape_ptr)) then
         call photgrid%inquire(rank=rank_)
         call C_F_POINTER(shape_ptr, shape, [rank_])
         call photgrid%inquire(shape=shape)
      endif

      if (C_ASSOCIATED(axis_min_ptr)) then
         call photgrid%inquire(rank=rank_)
         call C_F_POINTER(axis_min_ptr, axis_min, [rank_])
         call photgrid%inquire(axis_min=axis_min)
      endif

      if (C_ASSOCIATED(axis_max_ptr)) then
         call photgrid%inquire(rank=rank_)
         call C_F_POINTER(axis_max_ptr, axis_max, [rank_])
         call photgrid%inquire(axis_max=axis_max)
      endif

      call photgrid%inquire(rank=rank)

      ! Finish

      return

   end subroutine inquire_photgrid

   !****

   subroutine get_axis_label_specgrid(specgrid_ptr, i, axis_label) bind(C, name='get_axis_label_SpecGrid')

      type(C_PTR), value    :: specgrid_ptr
      integer(C_INT), value :: i
      character(C_CHAR)     :: axis_label(*)

      type(specgrid_t), pointer         :: specgrid
      integer                           :: rank
      character(LABEL_LEN), allocatable :: axis_labels(:)

      ! Set up the Fortran pointer

      call C_F_POINTER(specgrid_ptr, specgrid)

      ! Get the i'th label

      call specgrid%inquire(rank=rank)

      allocate(axis_labels(rank))

      call specgrid%inquire(axis_labels=axis_labels)

      if (i >= 1 .AND. i <= SIZE(axis_labels)) then
         call f_c_string(axis_labels(i), axis_label)
      else
         axis_label(1:1) = C_NULL_CHAR
      endif

      ! Finish

      return

   end subroutine get_axis_label_specgrid

   !****

   subroutine get_axis_label_photgrid(photgrid_ptr, i, axis_label) bind(C, name='get_axis_label_PhotGrid')

      type(C_PTR), value    :: photgrid_ptr
      integer(C_INT), value :: i
      character(C_CHAR)     :: axis_label(*)

      type(photgrid_t), pointer         :: photgrid
      integer                           :: rank
      character(LABEL_LEN), allocatable :: axis_labels(:)

      ! Set up the Fortran pointer

      call C_F_POINTER(photgrid_ptr, photgrid)

      ! Get the i'th label

      call photgrid%inquire(rank=rank)

      allocate(axis_labels(rank))

      call photgrid%inquire(axis_labels=axis_labels)

      if (i >= 1 .AND. i <= SIZE(axis_labels)) then
         call f_c_string(axis_labels(i), axis_label)
      else
         axis_label(1:1) = C_NULL_CHAR
      endif

      ! Finish

      return

   end subroutine get_axis_label_photgrid

   !****

   #:for name, arg_var, arg_type in (('intensity', 'mu', 'real(C_DOUBLE)'), &
                                     ('E_moment', 'k', 'integer(C_INT)'), &
                                     ('D_moment', 'l', 'integer(C_INT)'))

      subroutine interp_${name}$_SpecGrid(specgrid_ptr, x_vec, ${arg_var}$, n, lam, res, &
                                          stat, deriv_vec) bind(C, name='interp_${name}$_SpecGrid')

         type(C_PTR), value    :: specgrid_ptr
         real(C_DOUBLE)        :: x_vec(*)
         ${arg_type}$, value   :: ${arg_var}$
         integer(C_INT), value :: n
         real(C_DOUBLE)        :: lam(n)
         real(C_DOUBLE)        :: res(n-1)
         integer(C_INT)        :: stat
         logical(C_BOOL)       :: deriv_vec(*)

         type(specgrid_t), pointer :: specgrid
         integer                   :: rank

         ! Set up the Fortran pointer

         call C_F_POINTER(specgrid_ptr, specgrid)

         ! Interpolate the ${name}$

         call specgrid%inquire(rank=rank)

         call specgrid%interp_${name}$(x_vec(1:rank), ${arg_var}$, lam, res, stat, LOGICAL(deriv_vec(1:rank)))

         ! Finish

         return

      end subroutine interp_${name}$_specgrid

      !****

      subroutine interp_${name}$_photgrid(photgrid_ptr, x_vec, ${arg_var}$, res, &
                                          stat, deriv_vec) bind(C, name='interp_${name}$_PhotGrid')

         type(C_PTR), value  :: photgrid_ptr
         real(C_DOUBLE)      :: x_vec(*)
         ${arg_type}$, value :: ${arg_var}$
         real(C_DOUBLE)      :: res
         integer(C_INT)      :: stat
         logical(C_BOOL)     :: deriv_vec(*)

         type(photgrid_t), pointer :: photgrid
         integer                   :: rank

         ! Set up the Fortran pointer

         call C_F_POINTER(photgrid_ptr, photgrid)

         ! Interpolate the ${name}$

         call photgrid%inquire(rank=rank)

         call photgrid%interp_${name}$(x_vec(1:rank), ${arg_var}$, res, stat, LOGICAL(deriv_vec(1:rank)))

         ! Finish

         return

      end subroutine interp_${name}$_photgrid

   #:endfor

   !****
      
   #:for name, var in (('flux', 'F'),)

      subroutine interp_${name}$_specgrid(specgrid_ptr, x_vec, n, lam, res, &
                                          stat, deriv_vec) bind(C, name='interp_${name}$_SpecGrid')

         type(C_PTR), value    :: specgrid_ptr
         real(C_DOUBLE)        :: x_vec(*)
         integer(C_INT), value :: n
         real(C_DOUBLE)        :: lam(n)
         real(C_DOUBLE)        :: res(n-1)
         integer(C_INT)        :: stat
         logical(C_BOOL)       :: deriv_vec(*)

         type(specgrid_t), pointer :: specgrid
         integer                   :: rank

         ! Set up the Fortran pointer

         call C_F_POINTER(specgrid_ptr, specgrid)

         ! Interpolate the ${name}$

         call specgrid%inquire(rank=rank)

         call specgrid%interp_${name}$(x_vec(1:rank), lam, res, stat, LOGICAL(deriv_vec(1:rank)))

         ! Finish

         return

      end subroutine interp_${name}$_specgrid

      !****

      subroutine interp_${name}$_photgrid(photgrid_ptr, x_vec, res, &
                                          stat, deriv_vec) bind(C, name='interp_${name}$_PhotGrid')

         type(C_PTR), value :: photgrid_ptr
         real(C_DOUBLE)     :: x_vec(*)
         real(C_DOUBLE)     :: res
         integer(C_INT)     :: stat
         logical(C_BOOL)    :: deriv_vec(*)

         type(photgrid_t), pointer :: photgrid
         integer                   :: rank

         ! Set up the Fortran pointer

         call C_F_POINTER(photgrid_ptr, photgrid)

         ! Interpolate the ${name}$

         call photgrid%inquire(rank=rank)

         call photgrid%interp_${name}$(x_vec(1:rank), res, stat, LOGICAL(deriv_vec(1:rank)))

         ! Finish

         return

      end subroutine interp_${name}$_photgrid

   #:endfor

   !****

   subroutine open_file_(c_file_name, hdf5io, stat)

      character(C_CHAR)              :: c_file_name(*)
      type(hdf5io_t), intent(out)    :: hdf5io
      integer, intent(out), optional :: stat

      character(:), allocatable :: file_name
      
      ! Open the file

      call c_f_string(c_file_name, file_name)

      if (is_hdf5(file_name)) then

         hdf5io = hdf5io_t(file_name, OPEN_FILE_RO)

         if (PRESENT(stat)) stat = STAT_OK

      else

         if (PRESENT(stat)) then
            stat = STAT_FILE_NOT_FOUND
         else
            @:ABORT('file not found')
         endif

      endif

      ! Finish

      return

   end subroutine open_file_

end module cmsg_m
