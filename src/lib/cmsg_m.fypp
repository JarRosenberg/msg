! Module  : cmsg_m
! Purpose : C public interface for MSG modules
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module cmsg_m

   ! Uses

   use forum_m

   use msg_m

   use ISO_FORTRAN_ENV
   use ISO_C_BINDING

   ! No implicit typing

   implicit none

   ! Access specifiers

   private

   #:for prefix in ('specgrid', 'photgrid')
      public :: ${prefix}$_load
      public :: ${prefix}$_unload
      public :: ${prefix}$_inquire
      public :: ${prefix}$_interp_intensity
      public :: ${prefix}$_interp_D_moment
      public :: ${prefix}$_interp_flux
   #:endfor

   public :: photgrid_load_specgrid

   ! Procedures

contains

   #:for prefix, type in (('specgrid', 'specgrid_t'), ('photgrid', 'photgrid_t'))

      function ${prefix}$_load(c_filename) result(ptr) bind(C)

         character(C_CHAR) :: c_filename(*)
         type(C_PTR)       :: ptr

         type(${type}$), pointer   :: gr
         character(:), allocatable :: filename

         ! Allocate the grid

         allocate(gr)

         ! Load it from the file

         call c_f_string(c_filename, filename)

         gr = ${type}$(filename)

         ! Set up the C pointer

         ptr = C_LOC(gr)

         ! Finish

         return

      end function ${prefix}$_load

      !****

      subroutine ${prefix}$_unload(ptr) bind(C)

         type(C_PTR), value :: ptr

         type(${type}$), pointer :: gr

         ! Set up the Fortran pointer

         call C_F_POINTER(ptr, gr)

         ! Deallocate the grid

         if (ASSOCIATED(gr)) deallocate(gr)

         ! Finish

         return

      end subroutine ${prefix}$_unload

   #:endfor

   !****

   function photgrid_load_specgrid(c_filename, c_passband_filename) result(ptr) bind(C)

      character(C_CHAR) :: c_filename(*)
      character(C_CHAR) :: c_passband_filename(*)
      type(C_PTR)       :: ptr

      type(${type}$), pointer   :: gr
      character(:), allocatable :: filename
      character(:), allocatable :: passband_filename

      ! Allocate the grid

      allocate(gr)

      ! Load it from the file

      call c_f_string(c_filename, filename)
      call c_f_string(c_passband_filename, passband_filename)

      gr = ${type}$(filename, passband_filename)

      ! Set up the C pointer

      ptr = C_LOC(gr)

      ! Finish

      return

   end function photgrid_load_specgrid

   !****

   subroutine specgrid_inquire(ptr, lam_min, lam_max, shape_ptr, rank, axis_min_ptr, axis_max_ptr) bind(C)

      type(C_PTR), value :: ptr
      real(C_DOUBLE)     :: lam_min
      real(C_DOUBLE)     :: lam_max
      type(C_PTR), value :: shape_ptr
      integer(C_INT)     :: rank
      type(C_PTR), value :: axis_min_ptr
      type(C_PTR), value :: axis_max_ptr

      type(specgrid_t), pointer :: sg
      integer                   :: rank_
      integer, pointer          :: shape(:)
      real(RD), pointer         :: axis_min(:)
      real(RD), pointer         :: axis_max(:)

      ! Set up the Fortran pointer

      call C_F_POINTER(ptr, sg)

      ! Inquire metadata

      if (C_ASSOCIATED(shape_ptr)) then
         call sg%inquire(rank=rank_)
         call C_F_POINTER(shape_ptr, shape, [rank_])
         call sg%inquire(shape=shape)
      endif

      if (C_ASSOCIATED(axis_min_ptr)) then
         call sg%inquire(rank=rank_)
         call C_F_POINTER(axis_min_ptr, axis_min, [rank_])
         call sg%inquire(axis_min=axis_min)
      endif

      if (C_ASSOCIATED(axis_max_ptr)) then
         call sg%inquire(rank=rank_)
         call C_F_POINTER(axis_max_ptr, axis_max, [rank_])
         call sg%inquire(axis_max=axis_max)
      endif

      call sg%inquire(lam_min=lam_min, lam_max=lam_max, rank=rank)

      ! Finish

      return

   end subroutine specgrid_inquire

   !****

   subroutine photgrid_inquire(ptr, shape_ptr, rank, axis_min_ptr, axis_max_ptr) bind(C)

      type(C_PTR), value :: ptr
      type(C_PTR), value :: shape_ptr
      integer(C_INT)     :: rank
      type(C_PTR), value :: axis_min_ptr
      type(C_PTR), value :: axis_max_ptr
      
      type(photgrid_t), pointer :: pg
      integer                   :: rank_
      integer, pointer          :: shape(:)
      real(RD), pointer         :: axis_min(:)
      real(RD), pointer         :: axis_max(:)

      ! Set up the Fortran pointer

      call C_F_POINTER(ptr, pg)

      ! Inquire metadata

      if (C_ASSOCIATED(shape_ptr)) then
         call pg%inquire(rank=rank_)
         call C_F_POINTER(shape_ptr, shape, [rank_])
         call pg%inquire(shape=shape)
      endif

      if (C_ASSOCIATED(axis_min_ptr)) then
         call pg%inquire(rank=rank_)
         call C_F_POINTER(axis_min_ptr, axis_min, [rank_])
         call pg%inquire(axis_min=axis_min)
      endif

      if (C_ASSOCIATED(axis_max_ptr)) then
         call pg%inquire(rank=rank_)
         call C_F_POINTER(axis_max_ptr, axis_max, [rank_])
         call pg%inquire(axis_max=axis_max)
      endif

      call pg%inquire(rank=rank)

      ! Finish

      return

   end subroutine photgrid_inquire

   !****

   subroutine specgrid_get_axis_label(ptr, i, axis_label) bind(C)

      type(C_PTR), value    :: ptr
      integer(C_INT), value :: i
      character(C_CHAR)     :: axis_label(*)

      type(specgrid_t), pointer         :: sg
      integer                           :: rank
      character(LABEL_LEN), allocatable :: axis_labels(:)

      ! Set up the Fortran pointer

      call C_F_POINTER(ptr, sg)

      ! Get the i'th label

      call sg%inquire(rank=rank)

      allocate(axis_labels(rank))

      call sg%inquire(axis_labels=axis_labels)

      if (i >= 1 .AND. i <= SIZE(axis_labels)) then
         call f_c_string(axis_labels(i), axis_label)
      else
         axis_label(1:1) = C_NULL_CHAR
      endif

      ! Finish

      return

   end subroutine specgrid_get_axis_label

   !****

   subroutine photgrid_get_axis_label(ptr, i, axis_label) bind(C)

      type(C_PTR), value    :: ptr
      integer(C_INT), value :: i
      character(C_CHAR)     :: axis_label(*)

      type(photgrid_t), pointer         :: pg
      integer                           :: rank
      character(LABEL_LEN), allocatable :: axis_labels(:)

      ! Set up the Fortran pointer

      call C_F_POINTER(ptr, pg)

      ! Get the i'th label

      call pg%inquire(rank=rank)

      allocate(axis_labels(rank))

      call pg%inquire(axis_labels=axis_labels)

      if (i >= 1 .AND. i <= SIZE(axis_labels)) then
         call f_c_string(axis_labels(i), axis_label)
      else
         axis_label(1:1) = C_NULL_CHAR
      endif

      ! Finish

      return

   end subroutine photgrid_get_axis_label

   !****

   #:for name, var, arg_var, arg_type in (('intensity', 'I', 'mu', 'real(C_DOUBLE)'), &
                                          ('D_moment', 'D', 'l', 'integer(C_INT)'))

      subroutine specgrid_interp_${name}$(ptr, vx, ${arg_var}$, n, lam, ${var}$, stat, vderiv) bind(C)

         type(C_PTR), value    :: ptr
         real(C_DOUBLE)        :: vx(*)
         ${arg_type}$, value   :: ${arg_var}$
         integer(C_INT), value :: n
         real(C_DOUBLE)        :: lam(n)
         real(C_DOUBLE)        :: ${var}$(n)
         integer(C_INT)        :: stat
         logical(C_BOOL)       :: vderiv(n)

         type(specgrid_t), pointer :: sg
         integer                   :: rank

         ! Set up the Fortran pointer

         call C_F_POINTER(ptr, sg)

         ! Interpolate the ${name}$

         call sg%inquire(rank=rank)

         call sg%interp_${name}$(vx(1:rank), ${arg_var}$, lam, ${var}$, stat, LOGICAL(vderiv(1:rank)))

         ! Finish

         return

      end subroutine specgrid_interp_${name}$

      !****

      subroutine photgrid_interp_${name}$(ptr, vx, ${arg_var}$, ${var}$, stat, vderiv) bind(C)

         type(C_PTR), value  :: ptr
         real(C_DOUBLE)      :: vx(*)
         ${arg_type}$, value :: ${arg_var}$
         real(C_DOUBLE)      :: ${var}$
         integer(C_INT)      :: stat
         logical(C_BOOL)     :: vderiv(*)

         type(photgrid_t), pointer :: pg
         integer                   :: rank

         ! Set up the Fortran pointer

         call C_F_POINTER(ptr, pg)

         ! Interpolate the ${name}$

         call pg%inquire(rank=rank)

         call pg%interp_${name}$(vx(1:rank), ${arg_var}$, ${var}$, stat, LOGICAL(vderiv(1:rank)))

         ! Finish

         return

      end subroutine photgrid_interp_${name}$

   #:endfor

   !****
      
   #:for name, var in (('flux', 'F'),)

      subroutine specgrid_interp_${name}$(ptr, vx, n, lam, ${var}$, stat, vderiv) bind(C)

         type(C_PTR), value    :: ptr
         real(C_DOUBLE)        :: vx(*)
         integer(C_INT), value :: n
         real(C_DOUBLE)        :: lam(n)
         real(C_DOUBLE)        :: ${var}$(n)
         integer(C_INT)        :: stat
         logical(C_BOOL)       :: vderiv(*)

         type(specgrid_t), pointer :: sg
         integer                   :: rank

         ! Set up the Fortran pointer

         call C_F_POINTER(ptr, sg)

         ! Interpolate the ${name}$

         call sg%inquire(rank=rank)

         call sg%interp_${name}$(vx(1:rank), lam, ${var}$, stat, LOGICAL(vderiv(1:rank)))

         ! Finish

         return

      end subroutine specgrid_interp_${name}$

      !****

      subroutine photgrid_interp_${name}$(ptr, vx, ${var}$, stat, vderiv) bind(C)

         type(C_PTR), value :: ptr
         real(C_DOUBLE)     :: vx(*)
         real(C_DOUBLE)     :: ${var}$
         integer(C_INT)     :: stat
         logical(C_BOOL)    :: vderiv(*)

         type(photgrid_t), pointer :: pg
         integer                   :: rank

         ! Set up the Fortran pointer

         call C_F_POINTER(ptr, pg)

         ! Interpolate the ${name}$

         call pg%inquire(rank=rank)

         call pg%interp_${name}$(vx(1:rank), ${var}$, stat, LOGICAL(vderiv(1:rank)))

         ! Finish

         return

      end subroutine photgrid_interp_${name}$

   #:endfor

end module cmsg_m
