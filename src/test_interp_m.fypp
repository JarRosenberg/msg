#:include 'forum.inc'

module test_interp_m

  ! Uses

  use kinds_m
  use interp_m
  use order_m

  use ISO_FORTRAN_ENV

  ! No implicit typing

  implicit none

  ! Access specifiers

  private

  public :: test

contains
 
   subroutine test()

      call test_bicubic_setup_()
      call test_bicubic_interp_()

   end subroutine test

   !****

   subroutine test_bicubic_setup_()

      integer, parameter :: n_x = 4
      integer, parameter :: n_y = 6
      
      real(RD) :: x(n_x)
      real(RD) :: y(n_y)
      real(RD) :: f(n_x,n_y)
      real(RD) :: df(n_x-3,n_y-3,2,2,2,2)
      real(RD) :: df_chk(n_x-3,n_y-3,2,2,2,2)

      print *,'bicubic_setup'

      call bicubic_setup_arrange_()
      call bicubic_setup_act_()
      call bicubic_setup_assert_()

   contains      
      
      subroutine bicubic_setup_arrange_()

         integer :: i
         integer :: j

         x = [(i-1,i=1,n_x)]
         y = [(j-1,j=1,n_y)]**2

         do i = 1, n_x
            do j = 1, n_y
               call eval_biquadratic_(x(i), y(j), f(i,j))
            end do
         end do

      end subroutine bicubic_setup_arrange_

      !****
  
      subroutine bicubic_setup_act_()

         integer  :: i
         integer  :: j

         do i = 1, n_x-3
            do j = 1, n_y-3

               call bicubic_setup(x(i:i+3), y(j:j+3), f(i:i+3,j:j+3), df(i,j,:,:,:,:))

               call eval_biquadratic_(x(i+1), y(j+1), &
                    df_chk(i,j,1,1,1,1), df_chk(i,j,1,1,2,1), df_chk(i,j,1,1,1,2), df_chk(i,j,1,1,2,2))
               call eval_biquadratic_(x(i+2), y(j+1), &
                    df_chk(i,j,2,1,1,1), df_chk(i,j,2,1,2,1), df_chk(i,j,2,1,1,2), df_chk(i,j,2,1,2,2))
               call eval_biquadratic_(x(i+1), y(j+2), &
                    df_chk(i,j,1,2,1,1), df_chk(i,j,1,2,2,1), df_chk(i,j,1,2,1,2), df_chk(i,j,1,2,2,2))
               call eval_biquadratic_(x(i+2), y(j+2), &
                    df_chk(i,j,2,2,1,1), df_chk(i,j,2,2,2,1), df_chk(i,j,2,2,1,2), df_chk(i,j,2,2,2,2))

            end do
         end do

      end subroutine bicubic_setup_act_

      !****
      
      subroutine bicubic_setup_assert_()

         real(RD), parameter :: tol = 1E-13_RD

         real(RD), allocatable :: df_err(:,:,:,:,:,:)

         df_err = (df - df_chk)/df_chk

         if (ALL(ABS(df_err(:,:,:,:,1,1)) < tol)) then
            print *,'  PASS df(1,1)'
         else
            print *,'  FAIL df(1,1):', MAXVAL(ABS(df_err(:,:,:,:,1,1))), '>', tol
         end if

         if (ALL(ABS(df_err(:,:,:,:,2,1)) < tol)) then
            print *,'  PASS df(2,1)'
         else
            print *,'  FAIL df(2,1):', MAXVAL(ABS(df_err(:,:,:,:,2,1))), '>', tol
         end if

         if (ALL(ABS(df_err(:,:,:,:,1,2)) < tol)) then
            print *,'  PASS df(1,2)'
         else
            print *,'  FAIL df(1,2):', MAXVAL(ABS(df_err(:,:,:,:,1,2))), '>', tol
         end if

         if (ALL(ABS(df_err(:,:,:,:,2,2)) < tol)) then
            print *,'  PASS df(2,2)'
         else
            print *,'  FAIL df(2,2):', MAXVAL(ABS(df_err(:,:,:,:,2,2))), '>', tol
         end if

      end subroutine bicubic_setup_assert_

   end subroutine test_bicubic_setup_

   !****

   subroutine test_bicubic_interp_()

      integer, parameter :: n_x = 4
      integer, parameter :: n_y = 6
      integer, parameter :: n_over = 10
      integer, parameter :: n_x_int = n_over*(n_x-1) + 1
      integer, parameter :: n_y_int = n_over*(n_y-1) + 1
      
      real(RD) :: x(n_x)
      real(RD) :: y(n_y)
      real(RD) :: f(n_x,n_y)
      real(RD) :: df(n_x,n_y,2,2)
      real(RD) :: x_int(n_x_int)
      real(RD) :: y_int(n_y_int)
      real(RD) :: f_int(n_x_int,n_y_int)
      real(RD) :: df_dx_int(n_x_int,n_y_int)
      real(RD) :: df_dy_int(n_x_int,n_y_int)
      real(RD) :: d2f_dxdy_int(n_x_int,n_y_int)
      real(RD) :: f_chk(n_x_int,n_y_int)
      real(RD) :: df_dx_chk(n_x_int,n_y_int)
      real(RD) :: df_dy_chk(n_x_int,n_y_int)
      real(RD) :: d2f_dxdy_chk(n_x_int,n_y_int)

      print *,'bicubic_interp'

      call bicubic_interp_arrange_()
      call bicubic_interp_act_()
      call bicubic_interp_assert_()

   contains

      subroutine bicubic_interp_arrange_()

         integer :: i
         integer :: j

         x = [(i-1,i=1,n_x)]
         y = [(j-1,j=1,n_y)]

         do i = 1, n_x
            do j = 1, n_y
               call eval_bicubic_(x(i), y(j), df(i,j,1,1), df(i,j,2,1), df(i,j,1,2), df(i,j,2,2))
            end do
         end do

      end subroutine bicubic_interp_arrange_

      !****
  
      subroutine bicubic_interp_act_()

         integer  :: i
         integer  :: j
         integer  :: k
         integer  :: l
         integer  :: m
         real(RD) :: dx
         real(RD) :: dy
         real(RD) :: u
         real(RD) :: v
         real(RD) :: df_int(2,2)

         do i = 1, n_x-1
            do m = 1, n_over
               x_int(n_over*(i-1)+m) = x(i) + (x(i+1) - x(i))*(m-1)/n_over
            end do
         end do

         do j = 1, n_y-1
            do m = 1, n_over
               y_int(n_over*(j-1)+m) = y(j) + (y(j+1) - y(j))*(m-1)/n_over
            end do
         end do

         x_int(n_x_int) = x(n_x)
         y_int(n_y_int) = y(n_y)

         do i = 1, n_x_int
            do j = 1,n_y_int

               call locate(x, x_int(i), k)
               call locate(y, y_int(j), l)

               dx = x(k+1) - x(k)
               dy = y(l+1) - y(l)
               
               u = (x_int(i) - x(k))/dx
               v = (y_int(j) - y(l))/dy

               call bicubic_interp(df(k:k+1,l:l+1,:,:), dx, dy, u, v, df_int)

               f_int(i,j) = df_int(1,1)
               df_dx_int(i,j) = df_int(2,1)
               df_dy_int(i,j) = df_int(1,2)
               d2f_dxdy_int(i,j) = df_int(2,2)

               call eval_bicubic_(x_int(i), y_int(j), f_chk(i,j), df_dx_chk(i,j), df_dy_chk(i,j), d2f_dxdy_chk(i,j))

            end do
         end do

      end subroutine bicubic_interp_act_

      !****
      
      subroutine bicubic_interp_assert_()

         real(RD), parameter :: tol = 1E-13_RD

         real(RD), allocatable :: f_err(:,:)
         real(RD), allocatable :: df_dx_err(:,:)
         real(RD), allocatable :: df_dy_err(:,:)
         real(RD), allocatable :: d2f_dxdy_err(:,:)

         f_err = (f_int - f_chk)/f_chk
         df_dx_err = (df_dx_int - df_dx_chk)/f_chk
         df_dy_err = (df_dy_int - df_dy_chk)/f_chk
         d2f_dxdy_err = (d2f_dxdy_int - d2f_dxdy_chk)/f_chk

         if (ALL(ABS(f_err) < tol)) then
            print *,'  PASS f'
         else
            print *,'  FAIL f:', MAXVAL(ABS(f_err)), '>', tol
         end if

         if (ALL(ABS(df_dx_err) < tol)) then
            print *,'  PASS df_dx'
         else
            print *,'  FAIL df_dx:', MAXVAL(ABS(df_dx_err)), '>', tol
         end if

         if (ALL(ABS(df_dy_err) < tol)) then
            print *,'  PASS df_dy'
         else
            print *,'  FAIL df_dy:', MAXVAL(ABS(df_dy_err)), '>', tol
         end if

         if (ALL(ABS(d2f_dxdy_err) < tol)) then
            print *,'  PASS d2f_dxdy'
         else
            print *,'  FAIL d2f_dxdy:', MAXVAL(ABS(d2f_dxdy_err)), '>', tol
         end if


      end subroutine bicubic_interp_assert_

   end subroutine test_bicubic_interp_

   !****

   subroutine eval_biquadratic_(x, y, f, df_dx, df_dy, d2f_dxdy)

      real(RD), intent(in)            :: x
      real(RD), intent(in)            :: y
      real(RD), intent(out)           :: f
      real(RD), intent(out), optional :: df_dx
      real(RD), intent(out), optional :: df_dy
      real(RD), intent(out), optional :: d2f_dxdy

      f = x**2 + x*y**2 + 2*y + 4

      if (PRESENT(df_dx)) then
         df_dx = 2*x + y**2
      endif

      if (PRESENT(df_dy)) then
         df_dy = 2*x*y + 2
      endif

      if (PRESENT(d2f_dxdy)) then
         d2f_dxdy = 2*y
      endif

   end subroutine eval_biquadratic_

   !****

   subroutine eval_bicubic_(x, y, f, df_dx, df_dy, d2f_dxdy)

      real(RD), intent(in)            :: x
      real(RD), intent(in)            :: y
      real(RD), intent(out)           :: f
      real(RD), intent(out), optional :: df_dx
      real(RD), intent(out), optional :: df_dy
      real(RD), intent(out), optional :: d2f_dxdy

      f = x**3 + x*y**3 + 2*y**2 + 4

      if (PRESENT(df_dx)) then
         df_dx = 3*x**2 + y**3
      endif

      if (PRESENT(df_dy)) then
         df_dy = 3*x*y**2 + 4*y
      endif

      if (PRESENT(d2f_dxdy)) then
         d2f_dxdy = 3*y**2
      endif

   end subroutine eval_bicubic_

end module test_interp_m
 
