! Module   : specrad_factory_m
! Purpose  : factory procedures for specrad_t type
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module specrad_factory_m

  ! Uses
  
   use kinds_m
   use math_m
   
   use specrad_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Access specifiers

   private

   public :: specrad_from_table

   ! Procedures

contains

   function specrad_from_table (I, mu, lambda, w_0, dw, n_w, limb_law) result (sr)

      real(R8), intent(in) :: I(:,:)
      real(R8), intent(in) :: mu(:)
      real(R8), intent(in) :: lambda(:)
      real(R8), intent(in) :: w_0
      real(R8), intent(in) :: dw
      integer, intent(in)  :: n_w
      integer, intent(in)  :: limb_law
      type(specrad_t)      :: sr

      integer               :: n_mu
      integer               :: n_lambda
      real(R8), allocatable :: I_w(:,:)
      real(R8), allocatable :: x(:)
      integer               :: k
      real(R8)              :: w_a
      real(R8)              :: w_b
      integer               :: j
      real(R8), allocatable :: y(:)

      @:CHECK_BOUNDS(SIZE(I, 1), SIZE(mu))
      @:CHECK_BOUNDS(SIZE(I, 2), SIZE(lambda))

      ! Construct the specrad_t from the tabulated I(mu,lambda) data

      ! Transform the intensity data onto the uniform-w grid

      n_mu = SIZE(mu)
      n_lambda = SIZE(lambda)

      @:ASSERT(w_0 >= LOG(lambda(1)), out-of-range w)
      @:ASSERT(w_0 + n_w*dw <= LOG(lambda(n_lambda)), out-of-range w)

      allocate(I_w(n_mu,n_w))

      x = LOG(lambda)

      mu_loop : do j = 1, n_mu

         y = I(j,:)*lambda

         w_loop : do k = 1, n_w

            w_a = w_0 + (k-1)*dw
            w_b = w_0 + (k  )*dw

            I_w(j,k) = integrate_lin(x, y, w_a, w_b)/(w_b - w_a)

         end do w_loop

      end do mu_loop

      ! Create the specrad_t

      sr = specrad_t(I_w, mu, w_0, dw, limb_law)

      ! Finish

   end function specrad_from_table

end module specrad_factory_m
