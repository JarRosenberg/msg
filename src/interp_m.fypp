! Module  : interp_m
! Purpose : interpolation
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module interp_m

   ! Uses

   use kinds_m
   use order_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Interfaces

   interface interp_bicubic
      module procedure interp_bicubic_0_
   end interface interp_bicubic

   ! Access specifiers

   private

   public :: interp_bicubic

   ! Procedures

contains

   function interp_bicubic_0_(func, x, y, x_int, y_int, d_dx, d_dy) result (f_int)

      interface
         function func(i_x, i_y, d_dx, d_dy)
            use kinds_m
            integer, intent(in)           :: i_x
            integer, intent(in)           :: i_y
            logical, intent(in), optional :: d_dx
            logical, intent(in), optional :: d_dy
            real(RD)                      :: func
         end function func
      end interface
      real(RD), intent(in)          :: x(:)
      real(RD), intent(in)          :: y(:)
      real(RD), intent(in)          :: x_int
      real(RD), intent(in)          :: y_int
      logical, intent(in), optional :: d_dx
      logical, intent(in), optional :: d_dy
      real(RD)                      :: f_int

      logical  :: d_dx_
      logical  :: d_dy_
      integer  :: i
      integer  :: j
      real(RD) :: delta_x
      real(RD) :: delta_y
      real(RD) :: u
      real(RD) :: v
      real(RD) :: f(2,2)
      real(RD) :: df_du(2,2)
      real(RD) :: df_dv(2,2)
      real(RD) :: d2f_dudv(2,2)
      real(RD) :: A(4,4)
      real(RD) :: P(4)
      real(RD) :: Q(4)

      if (PRESENT(d_dx)) then
         d_dx_ = d_dx
      else
         d_dx_ = .FALSE.
      endif

      if (PRESENT(d_dy)) then
         d_dy_ = d_dy
      else
         d_dy_ = .FALSE.
      endif
      
      ! Locate the cell within the grid

      call locate(x, x_int, i)
      call locate(y, y_int, j)

      @:ASSERT(i >= 1 .AND. i < SIZE(x), out-of-bounds interpolation)
      @:ASSERT(j >= 1 .AND. j < SIZE(y), out-of-bounds interpolation)

      delta_x = x(i+1) - x(i)
      delta_y = y(j+1) - y(j)

      u = (x_int - x(i))/delta_x
      v = (y_int - y(j))/delta_y

      ! Evaluate the function and its derivatives

      f(1,1) = func(i  ,j  )
      f(2,1) = func(i+1,j  )
      f(1,2) = func(i  ,j+1)
      f(2,2) = func(i+1,j+1)

      df_du(1,1) = func(i  ,j  , d_dx=.TRUE.)*delta_x
      df_du(2,1) = func(i+1,j  , d_dx=.TRUE.)*delta_x
      df_du(1,2) = func(i  ,j+1, d_dx=.TRUE.)*delta_x
      df_du(2,2) = func(i+1,j+1, d_dx=.TRUE.)*delta_x

      df_dv(1,1) = func(i  ,j  , d_dy=.TRUE.)*delta_y
      df_dv(2,1) = func(i+1,j  , d_dy=.TRUE.)*delta_y
      df_dv(1,2) = func(i  ,j+1, d_dy=.TRUE.)*delta_y
      df_dv(2,2) = func(i+1,j+1, d_dy=.TRUE.)*delta_y

      d2f_dudv(1,1) = func(i  ,j  , d_dx=.TRUE., d_dy=.TRUE.)*delta_x*delta_y
      d2f_dudv(2,1) = func(i+1,j  , d_dx=.TRUE., d_dy=.TRUE.)*delta_x*delta_y
      d2f_dudv(1,2) = func(i  ,j+1, d_dx=.TRUE., d_dy=.TRUE.)*delta_x*delta_y
      d2f_dudv(2,2) = func(i+1,j+1, d_dx=.TRUE., d_dy=.TRUE.)*delta_x*delta_y

      ! Evaluate the coefficients

      call eval_coeffs_(f, df_du, df_dv, d2f_dudv, A)

      ! Set up the basis vectors

      if (d_dx_) then
         P(1) = 0._RD
         P(2) = 1._RD
         P(3) = 2._RD*u
         P(4) = 3._RD*u**2
         P = P/delta_x
      else
         P(1) = 1._RD
         P(2) = u
         P(3) = u**2
         P(4) = u**3
      endif
      
      if (d_dy_) then
         Q(1) = 0._RD
         Q(2) = 1._RD
         Q(3) = 2._RD*v
         Q(4) = 3._RD*v**2
         Q = Q/delta_y
      else
         Q(1) = 1._RD
         Q(2) = v
         Q(3) = v**2
         Q(4) = v**3
      endif

      ! Evaluate the interpolated function

      f_int = DOT_PRODUCT(P, MATMUL(A, Q))

      ! Finish

      return

   end function interp_bicubic_0_

   !****
      
   subroutine eval_coeffs_(f, df_du, df_dv, d2f_dudv, A)

      real(RD), intent(in)  :: f(:,:)
      real(RD), intent(in)  :: df_du(:,:)
      real(RD), intent(in)  :: df_dv(:,:)
      real(RD), intent(in)  :: d2f_dudv(:,:)
      real(RD), intent(out) :: A(:,:)

      real(RD), parameter :: C(4,4) = RESHAPE([ &
           1, 0, 0, 0, &
           0, 0, 1, 0, &
           -3, 3, -2, -1, &
           2, -2, 1, 1], SHAPE(C))

      real(RD) :: B(4,4)

      ! Evaluate the coefficient matrix

      B(1:2,1:2) = f
      B(3:4,1:2) = df_du
      B(1:2,3:4) = df_dv
      B(3:4,3:4) = d2f_dudv

      A = MATMUL(TRANSPOSE(C), MATMUL(B, C))

      ! Finish

      return

   end subroutine eval_coeffs_

end module interp_m
