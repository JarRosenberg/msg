! Module  : interp_m
! Purpose : interpolation
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module interp_m

   ! Uses

   use kinds_m
   use order_m

   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Interfaces

   interface interp_bicubic
      module procedure interp_bicubic_0_
   end interface interp_bicubic

   ! Access specifiers

   private

   public :: interp_bicubic

   ! Procedures

contains

   subroutine interp_bicubic_0_(proc, x, y, x_int, y_int, f_int, stat, d_dx, d_dy)

      interface
         subroutine proc(i_x, i_y, f, stat, d_dx, d_dy)
            use kinds_m
            integer, intent(in)            :: i_x
            integer, intent(in)            :: i_y
            real(RD), intent(out)          :: f
            integer, intent(out), optional :: stat
            logical, intent(in), optional  :: d_dx
            logical, intent(in), optional  :: d_dy
         end subroutine proc
      end interface
      real(RD), intent(in)           :: x(:)
      real(RD), intent(in)           :: y(:)
      real(RD), intent(in)           :: x_int
      real(RD), intent(in)           :: y_int
      real(RD), intent(out)          :: f_int
      integer, intent(out), optional :: stat
      logical, intent(in), optional  :: d_dx
      logical, intent(in), optional  :: d_dy

      logical  :: d_dx_
      logical  :: d_dy_
      integer  :: i
      integer  :: j
      real(RD) :: delta_x
      real(RD) :: delta_y
      real(RD) :: u
      real(RD) :: v
      integer  :: k
      integer  :: l
      real(RD) :: f(2,2)
      real(RD) :: df_du(2,2)
      real(RD) :: df_dv(2,2)
      real(RD) :: d2f_dudv(2,2)
      real(RD) :: df_dx
      real(RD) :: df_dy
      real(RD) :: d2f_dxdy
      real(RD) :: A(4,4)
      real(RD) :: P(4)
      real(RD) :: Q(4)

      if (PRESENT(d_dx)) then
         d_dx_ = d_dx
      else
         d_dx_ = .FALSE.
      endif

      if (PRESENT(d_dy)) then
         d_dy_ = d_dy
      else
         d_dy_ = .FALSE.
      endif
      
      ! Locate the cell within the grid

      call locate(x, x_int, i)
      call locate(y, y_int, j)

      if (i < 1 .OR. i >= SIZE(x)) then
         if (PRESENT(stat)) then
            stat = STAT_OUT_OF_BOUNDS
            return
         else
            @:ABORT(out-of-bounds)
         endif
      endif

      if (j < 1 .OR. j >= SIZE(y)) then
         if (PRESENT(stat)) then
            stat = STAT_OUT_OF_BOUNDS
            return
         else
            @:ABORT(out-of-bounds)
         endif
      endif

      delta_x = x(i+1) - x(i)
      delta_y = y(j+1) - y(j)

      u = (x_int - x(i))/delta_x
      v = (y_int - y(j))/delta_y

      ! Evaluate the function and its derivatives at cell corners

      do k = 1, 2
         do l = 1,2

            call proc(i+k-1,j+l-1, f(k,l), stat)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            endif
                  
            call proc(i+k-1,j+l-1, df_dx, stat, d_dx=.TRUE.)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            endif
            df_du(k,l) = df_dx*delta_x
                  
            call proc(i+k-1,j+l-1, df_dy, stat, d_dy=.TRUE.)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            endif
            df_dv(k,l) = df_dy*delta_y
                  
            call proc(i+k-1,j+l-1, d2f_dxdy, stat, d_dx=.TRUE., d_dy=.TRUE.)
            if (PRESENT(stat)) then
               if (stat /= STAT_OK) return
            endif
            d2f_dudv(k,l) = d2f_dxdy*delta_x*delta_y

         end do
      end do
                  
      ! Evaluate the interpolation coefficients

      call eval_coeffs_(f, df_du, df_dv, d2f_dudv, A)

      ! Set up the basis vectors

      if (d_dx_) then
         P(1) = 0._RD
         P(2) = 1._RD
         P(3) = 2._RD*u
         P(4) = 3._RD*u**2
         P = P/delta_x
      else
         P(1) = 1._RD
         P(2) = u
         P(3) = u**2
         P(4) = u**3
      endif
      
      if (d_dy_) then
         Q(1) = 0._RD
         Q(2) = 1._RD
         Q(3) = 2._RD*v
         Q(4) = 3._RD*v**2
         Q = Q/delta_y
      else
         Q(1) = 1._RD
         Q(2) = v
         Q(3) = v**2
         Q(4) = v**3
      endif

      ! Evaluate the interpolated function

      f_int = DOT_PRODUCT(P, MATMUL(A, Q))

      ! Finish

      return

   end subroutine interp_bicubic_0_

   !****
      
   subroutine eval_coeffs_(f, df_du, df_dv, d2f_dudv, A)

      real(RD), intent(in)  :: f(:,:)
      real(RD), intent(in)  :: df_du(:,:)
      real(RD), intent(in)  :: df_dv(:,:)
      real(RD), intent(in)  :: d2f_dudv(:,:)
      real(RD), intent(out) :: A(:,:)

      real(RD), parameter :: C(4,4) = RESHAPE([ &
           1, 0, 0, 0, &
           0, 0, 1, 0, &
           -3, 3, -2, -1, &
           2, -2, 1, 1], SHAPE(C))

      real(RD) :: B(4,4)

      ! Evaluate the coefficient matrix

      B(1:2,1:2) = f
      B(3:4,1:2) = df_du
      B(1:2,3:4) = df_dv
      B(3:4,3:4) = d2f_dudv

      A = MATMUL(TRANSPOSE(C), MATMUL(B, C))

      ! Finish

      return

   end subroutine eval_coeffs_

end module interp_m
