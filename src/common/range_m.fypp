! Module  : range_m
! Purpose : define range_t abstract type, represnting an ordered sequence
!           of values spanning a range
!
! Copyright 2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module range_m

   ! Uses

   use kinds_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type, abstract :: range_t
   contains
      procedure(inquire_), deferred :: inquire
      procedure(get_), deferred     :: get
      procedure(get_all_), deferred :: get_all
      procedure(locate_), deferred  :: locate
   end type range_t

   ! Interfaces

   abstract interface

      subroutine inquire_(self, n, min, max)
         use kinds_m
         import range_t
         class(range_t), intent(in)      :: self
         integer, intent(out), optional  :: n
         real(RD), intent(out), optional :: min
         real(RD), intent(out), optional :: max
      end subroutine inquire_

      subroutine get_(self, i, x, stat)
         use kinds_m
         import range_t
         class(range_t), intent(in)     :: self
         integer, intent(in)            :: i
         real(RD), intent(out)          :: x
         integer, intent(out), optional :: stat
      end subroutine get_

      subroutine get_all_(self, x)
         use kinds_m
         import range_t
         class(range_t), intent(in)  :: self
         real(RD), intent(out)       :: x(:)
      end subroutine get_all_

      subroutine locate_(self, x, i, right)
         use kinds_m
         import range_t
         class(range_t), intent(in)    :: self
         real(RD), intent(in)          :: x
         integer, intent(inout)        :: i
         logical, intent(in), optional :: right
      end subroutine locate_

   end interface

   interface range_t

      module function range_t_subset_(ra_in, i_a, i_b) result(ra)
        class(range_t), intent(in)  :: ra_in
        integer, intent(in)         :: i_a
        integer, intent(in)         :: i_b
        class(range_t), allocatable :: ra
      end function range_t_subset_

   end interface range_t
   
   interface read

      module subroutine read_(hi, ra)
         use hdf5io_m
         type(hdf5io_t), intent(inout)            :: hi
         class(range_t), allocatable, intent(out) :: ra
      end subroutine read_

   end interface read

   interface write

      module subroutine write_(hi, ra)
         use hdf5io_m
         type(hdf5io_t), intent(inout)  :: hi
         class(range_t), intent(in)    :: ra
      end subroutine write_

   end interface write

   ! Access specifiers

   private

   public :: range_t
   public :: read
   public :: write

end module range_m
