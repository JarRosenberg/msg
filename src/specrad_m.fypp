! Module  : specrad_m
! Purpose : define specrad_t type, for representing spectral radiance
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module specrad_m

   ! Uses

   use kinds_m
   use const_m
   use hdf5io_m

   use fit_m
   use limb_m
   use math_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type specrad_t
      private
      type(limb_t)          :: li
      real(R8), allocatable :: I_1(:)
      real(R8), allocatable :: a(:,:)
      real(R8)              :: w_0
      real(R8)              :: dw
      integer               :: n_a
      integer               :: n_w
   contains
      private
      procedure, public :: I
      procedure, public :: F
      procedure         :: locate_
   end type specrad_t

   ! Interfaces

   interface specrad_t
      module procedure specrad_t_
      module procedure specrad_t_fit_
      module procedure specrad_t_rebin_
   end interface specrad_t

   interface read
      module procedure read_
   end interface read

   interface write
      module procedure write_
   end interface write

   ! Access specifiers

   private

   public :: specrad_t
   public :: read
   public :: write

   ! Procedures

contains

   function specrad_t_(I_1, a, w_0, dw, li) result (sr)

      real(R8), intent(in)     :: I_1(:)
      real(R8), intent(in)     :: a(:,:)
      real(R8), intent(in)     :: w_0
      real(R8), intent(in)     :: dw
      type(limb_t), intent(in) :: li
      type(specrad_t)          :: sr

      integer :: n_a
      integer :: n_w

      @:CHECK_BOUNDS(SIZE(I_1), SIZE(a, 2))

      ! Construct the specrad_t from the supplied data

      n_a = li%n_basis()
      n_w = SIZE(I_1)

      @:ASSERT(SIZE(a, 1) == n_a, invalid number of coefficients)

      sr%li = li

      sr%I_1 = I_1
      sr%a = a

      sr%w_0 = w_0
      sr%dw = dw

      sr%n_a = n_a
      sr%n_w = n_w

      ! Finish

      return

   end function specrad_t_

   !****

   function specrad_t_fit_(I, mu, w_0, dw, li) result (sr)

      real(R8), intent(in)     :: I(:,:)
      real(R8), intent(in)     :: mu(:)
      real(R8), intent(in)     :: w_0
      real(R8), intent(in)     :: dw
      type(limb_t), intent(in) :: li
      type(specrad_t)          :: sr

      integer               :: n_mu
      real(R8), allocatable :: I_1(:)
      integer               :: n_w
      real(R8), allocatable :: y(:,:)
      integer               :: k
      integer               :: n_a
      real(R8), allocatable :: a(:,:)

      @:CHECK_BOUNDS(SIZE(I, 1), SIZE(mu))

      ! Construct the specrad_t by fitting a limb-darkening law to
      ! I(mu,w)

      ! Set the normal intensity

      n_mu = SIZE(mu)

      I_1 = I(n_mu,:)

      ! Set up the fit data

      n_w = SIZE(I, 2)

      allocate(y(n_mu,n_w))

      w_loop : do k = 1, n_w
         y(:,k) = 1._R8 - I(:,k)/I_1(k)
      end do w_loop

      ! Do the fit

      n_a = li%n_basis()

      allocate(a(n_a,n_w))

      call gls_fit(mu, y, f_, a)

      ! Construct the specrad_t

      sr = specrad_t(I_1, a, w_0, dw, li)

      ! Finish

      return

   contains

      function f_ (mu, n)

         real(R8), intent(in) :: mu
         integer, intent(in)  :: n
         real(R8)             :: f_(n)

         f_ = li%I_basis(mu)

      end function f_

   end function specrad_t_fit_

   !****

   function specrad_t_rebin_(sr_in, w_min, w_max, dw) result (sr)

      type(specrad_t), intent(in)    :: sr_in
      real(R8), intent(in), optional :: w_min
      real(R8), intent(in), optional :: w_max
      real(R8), intent(in), optional :: dw
      type(specrad_t)                :: sr

      real(R8)              :: w_min_
      real(R8)              :: w_max_
      real(R8)              :: dw_
      integer               :: n_w
      real(R8), allocatable :: w_in(:)
      integer               :: k
      real(R8), allocatable :: w(:)
      real(R8), allocatable :: I_1(:)
      real(R8), allocatable :: a(:,:)
      integer               :: j
      real(R8), allocatable :: y(:)

      ! Construct the specrad_t by rebinning sr_in

      if (PRESENT(w_min)) then
         w_min_ = w_min
      else
         w_min_ = sr_in%w_0
      endif

      if (PRESENT(w_max)) then
         w_max_ = w_max
      else
         w_max_ = sr_in%w_0 + sr_in%dw*sr_in%n_w
      endif

      if (PRESENT(dw)) then
         dw_ = dw
      else
         dw_ = sr_in%dw
      endif

      @:ASSERT(w_min_ >= sr_in%w_0, invalid w_min)
      @:ASSERT(w_max_ <= sr_in%w_0 + sr_in%dw*sr_in%n_w, invalid w_max)

      ! Determine the new number of bins

      n_w = CEILING((w_max_ - w_min_)/dw_)

      ! (fix required for when the default w_min_ and w_max_ are
      ! used; otherwise, the final bin falls outside the original grid)

      if (dw_*n_w > sr_in%dw*sr_in%n_w) n_w = n_w - 1

      ! Construct the axes

      w_in = sr_in%w_0 + sr_in%dw*[(k-1,k=1,sr_in%n_w+1)]
      w = w_min_ + dw*[(k-1,k=1,n_w+1)]

      ! Allocate the new data arrays

      allocate(I_1(n_w))
      allocate(a(sr_in%n_a,n_w))

      ! Do the rebinning

      do k = 1, n_w
         I_1(k) = integrate_con(w_in, sr_in%I_1, w(k), w(k+1))/(w(k+1) - w(k))
      end do

      do j = 1, sr_in%n_a

         y = sr_in%I_1*sr_in%a(j,:)

         do k = 1, n_w
            a(j,k) = integrate_con(w_in, y, w(k), w(k+1))/(w(k+1) - w(k))
         end do

         a(j,:) = a(j,:)/I_1

      end do
            
      ! Create the specrad_t

      sr = specrad_t(I_1, a, w_min_, dw_, sr_in%li)

      ! Finish

      return

   end function specrad_t_rebin_

   !****

   subroutine read_(hi, sr)

      type(hdf5io_t), intent(inout) :: hi
      type(specrad_t), intent(out)  :: sr

      character(TYPE_LEN)   :: type
      real(R8)              :: w_0
      real(R8)              :: dw
      type(hdf5io_t)        :: hi_li
      type(limb_t)          :: li
      real(R8), allocatable :: I_1(:)
      real(R8), allocatable :: a(:,:)

      ! Read the specrad_t

      call hi%read_attr('TYPE', type)
      @:ASSERT(type == 'specrad_t',invalid type)

      call hi%read_attr('w_0', w_0)
      call hi%read_attr('dw', dw)

      hi_li = hdf5io_t(hi, 'li')
      call write(hi_li, li)
      call hi_li%final()

      call hi%alloc_read_dset('I_1', I_1)
      call hi%alloc_read_dset('a', a)

      sr = specrad_t(I_1, a, w_0, dw, li)

      ! Finish

      return

   end subroutine read_

   !****

   subroutine write_ (hi, sr)

      type(hdf5io_t), intent(inout) :: hi
      type(specrad_t), intent(in)   :: sr

      type(hdf5io_t) :: hi_li

      ! Write the specrad_t

      call hi%write_attr('TYPE', 'specrad_t')

      call hi%write_attr('w_0', sr%w_0)
      call hi%write_attr('dw', sr%dw)

      hi_li = hdf5io_t(hi, 'li')
      call write(hi_li, sr%li)
      call hi_li%final()

      call hi%write_dset('I_1', sr%I_1)
      call hi%write_dset('a', sr%a)

      ! Finish

      return

   end subroutine write_

   !****

   function I(self, mu, w_base, w_off, n_w)

      class(specrad_t), intent(in) :: self
      real(R8), intent(in)        :: mu
      real(R8), intent(in)        :: w_base
      real(R8), intent(in)        :: w_off
      integer, intent(in)         :: n_w
      real(R8)                    :: I(n_w)

      integer               :: k
      real(R8)              :: u
      real(R8), allocatable :: b(:)
      integer               :: i_w

      ! Set up interpolation starting index and weight

      call self%locate_(w_base, w_off, k, u)

      @:ASSERT(k >= 1 .AND. k+n_w-1 < self%n_w, out-of-bounds interpolation)

      ! Set up the intensity basis vector

      b = self%li%I_basis(mu)

      ! Evaluate the intensity

      !$OMP PARALLEL DO
      w_loop : do i_w = 1, n_w
         I(i_w) = &
              (1._R8-u)*self%I_1(k+i_w-1)*(1._R8 - DOT_PRODUCT(self%a(:,k+i_w-1), b)) + &
              (      u)*self%I_1(k+i_w  )*(1._R8 - DOT_PRODUCT(self%a(:,k+i_w  ), b))
      end do w_loop

      ! Finish

      return

   end function I

   !****

   function F (self, w_base, w_off, n_w)

      class(specrad_t), intent(in) :: self
      real(R8), intent(in)        :: w_base
      real(R8), intent(in)        :: w_off
      integer, intent(in)         :: n_w
      real(R8)                    :: F(n_w)

      integer  :: k
      real(R8) :: u
      real(R8) :: b(self%n_a)
      integer  :: i_w

      ! Set up interpolation starting index and weight

      call self%locate_(w_base, w_off, k, u)

      @:ASSERT(k >= 1 .AND. k+n_w-1 < self%n_w, out-of-bounds interpolation)

      ! Set up the flux basis vector

      b = self%li%F_basis()

      ! Evaluate the flux

      !$OMP PARALLEL DO
      w_loop : do i_w = 1, n_w
         F(i_w) = &
              (1._R8-u)*self%I_1(k+i_w-1)*TWOPI*(0.5_R8 - DOT_PRODUCT(self%a(:,k+i_w-1), b)) + &
              (      u)*self%I_1(k+i_w  )*TWOPI*(0.5_R8 - DOT_PRODUCT(self%a(:,k+i_w  ), b))
      end do w_loop

      ! Finish

      return

   end function F

   !****

   subroutine locate_(self, w_base, w_off, k, u)

      class(specrad_t), intent(in)     :: self
      real(R8), intent(in)            :: w_base
      real(R8), intent(in)            :: w_off
      integer, intent(out)            :: k
      real(R8), intent(out), optional :: u

      real(R8) :: w_pri

      ! Set up k such that (k-1)*self%dw <= w' < k*self%dw, where 
      ! w' = (w_base-self%w_0)+w_off

      w_pri = (w_base-self%w_0) + w_off

      k = FLOOR(w_pri/self%dw) + 1

      ! Set up the associated interpolation weight

      if (PRESENT(u)) then

         u = w_pri/self%dw - (k-1)

         @:ASSERT_DEBUG(u >= 0._R8, invalid interpolation weight)
         @:ASSERT_DEBUG(u <= 1._R8, invalid interpolation weight)

      endif

      ! Finish

      return

   end subroutine locate_

end module specrad_m
