! Module   : make_radint
! Purpose  : create radint files from synspec files
!
! Copyright 2021 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

program make_radint

   ! Uses

   use kinds_m
   use const_m
   use hdf5io_m
   use memory_m
   use order_m
   use system_m

   use radint_m
   use radint_factory_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Variables

   character(:), allocatable :: filename_in
   integer                   :: n_mu
   real(R8)                  :: mu_0
   real(R8)                  :: R
   character(:), allocatable :: limb_law
   character(:), allocatable :: filename_out

   real(R8), allocatable :: I(:,:)
   real(R8), allocatable :: lambda(:)
   integer               :: n_lambda
   real(R8)              :: w_0
   real(R8)              :: dw
   integer               :: n_w
   integer               :: law
   integer               :: j
   real(R8), allocatable :: mu(:)
   type(radint_t)        :: ri
   type(hdf5io_t)        :: hi

   ! Read command-line arguments

   @:ASSERT(n_arg() == 6,{Syntax: make_radint filename_in n_mu, mu_0 R limb_law filename_out})

   call get_arg(1, filename_in)
   call get_arg(2, n_mu)
   call get_arg(3, mu_0)
   call get_arg(4, R)
   call get_arg(5, limb_law)
   call get_arg(6, filename_out)

   ! Read data from the synspec file

   call read_data(filename_in, n_mu, lambda, I)

   n_lambda = SIZE(lambda)

   ! Set up binning parameters

   dw = 1._R8/R
   w_0 = LOG(lambda(1))
   n_w = FLOOR((lambda(n_lambda) - lambda(1))/dw)

   ! Create the radint_t

   select case (limb_law)
   case ('LINEAR')
      law = LINEAR_LAW
   case ('CLARET')
      law = CLARET_LAW
   case default
      @:ABORT(invalid limb_law)
   end select

   mu = [((mu_0*(n_mu-j) + 1._R8*(j-1))/(n_mu-1))]

   ri = radint_from_table(I, mu, lambda, w_0, dw, n_w, law)

   ! Write the radint_t

   hi = hdf5io_t(filename_out, CREATE_FILE, comp_level=9)
   call write(hi, ri)
   call hi%final()

   ! Finish

contains

   subroutine read_data (filename, n_mu, lambda, I)

      character(*), intent(in)           :: filename
      integer, intent(in)                :: n_mu
      real(R8), allocatable, intent(out) :: lambda(:)
      real(R8), allocatable, intent(out) :: I(:,:)

      integer              :: unit
      real(R8)             :: H
      integer              :: d_lam
      integer              :: n_lam
      integer, allocatable :: ind(:)
      integer              :: i_lam
      integer              :: n_dup

      ! Open the input file

      open(NEWUNIT=unit, FILE=filename, STATUS='OLD')

      ! Read in the wavelength and intensity data

      d_lam = 1024

      allocate(lambda(d_lam))
      allocate(I(n_mu,d_lam))

      n_lam = 0

      read_loop : do

         n_lam = n_lam + 1

         ! If necessary, expand arrays

         if(n_lam > d_lam) then
            d_lam = d_lam*2
            call reallocate(lambda, [d_lam])
            call reallocate(I, [n_mu,d_lam])
         endif

         ! Read a block of data

         read(unit, *, END=100) lambda(n_lam), H
         read(unit,*) I(:,n_lam)

         I(:,n_lam) = I(n_mu:1:-1,n_lam)

         ! Convert to correct units
         !   intensity: ergs/s/cm**2/Angstom/sr

         I(:,n_lam) = I(:,n_lam)*C_LIGHT/(lambda(n_lam)*1E-8_R8)**2

      end do read_loop

100   continue

      close(unit)

      n_lam = n_lam - 1
      d_lam = n_lam

      call reallocate(lambda, [d_lam])
      call reallocate(I, [n_mu,d_lam])

      write(OUTPUT_UNIT, *) 'n_lam (as read) :', n_lam

      ! Sort the data by wavelength

      ind = sort_indices(lambda)

      lambda = lambda(ind)
      I = I(:,ind)

      ! Merge duplicate points

      n_lam = 1

      n_dup = 0

      merge_loop : do i_lam = 2,d_lam

         if(lambda(i_lam) == lambda(n_lam)) then

            I(:,n_lam) = I(:,n_lam) + I(:,i_lam)
            n_dup = n_dup + 1

         else

            if(n_dup > 0) then

               I(:,n_lam) = I(:,n_lam)/(n_dup + 1)
               n_dup = 0

            endif

            n_lam = n_lam + 1

            lambda(n_lam) = lambda(i_lam)
            I(:,n_lam) = I(:,i_lam)

         endif

      end do merge_loop

      if(n_dup > 0) then
         I(:,n_lam) = I(:,n_lam)/(n_dup + 1)
      endif

      d_lam = n_lam

      call reallocate(lambda, [d_lam])
      call reallocate(I, [n_mu,d_lam])

      write(OUTPUT_UNIT, *) 'n_lam (merged)  :', n_lam

      ! Finish

      return

   end subroutine read_data

end program make_radint
